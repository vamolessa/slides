<!DOCTYPE html>
<link rel="stylesheet" type="text/css" href="../style.css">
<title>design de apis</title>

<main>
	<h1>design de apis
	<h2>reflex√µes a respeito de boas apis
</main>

<section>
	<h1>intrinsicamente relacionado a abstra√ß√µes</h1>
	<h2>api = deifinir/comunicar abstra√ß√£o</h2>
</section>

<!--
	TODAS abstra√ß√µes vazam!!
	escolher onde tracar a linha da abstra√ß√£o
	ex de abstracao:
	- carro manual => passar marcha √© um vazamento da implementa√ß√£o do carro (como funciona internamente)
	- carro automatico => n√£o √© 100% pois ainda existem `1`, `2`, `P`, al√©m do `D`
	- mesmo que fosse "100%", ainda existe manuten√ß√£o => precisa entender quando precisa levar ao mec√¢nico, checar agua, oleo, etc
	- toda abstra√ß√£o vaza detalhes de implementa√ß√£o!
		- e tudo bem! isso n√£o invalida suas utilidades
		- porem, existe um gradiente a√≠! mesmo sempre existindo vazamento, √© de nosso interesse minimiz√°-lo!!
		- https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ&index=11

	importante: escolher onde tra√ßa a linha de abstra√ß√£o
		- escolher o que √© abstraido e o que √© exposto
		- ser consciente quanto a isso!
	lembrar sempre qual a raz√£o da exist√™ncia das abstra√ß√µes: esconder detalhes/gerenciar complexidade
	IMPORTANTE: os detalhes e sua complexidade AINDA EST√ÉO L√Å e n√£o devemos ignor√°-los!

	faca de dois legumes: abstrair significa esconder detalhes e adicionar contexto implic√≠to
	se quem vai usar api n√£o estiver a par desse contexto impl√≠cito... coisas ruins podem acontecer :')
	ex: mike conversa naturalmente com lucas, dustin e will.
	mas √†s vezes tem dificuldade com a eleven √†s vezes tendo que explicar conceitos
	que outrora fossem b√°sicos e esperados que todos o tivessem

	https://www.reddit.com/r/programming/comments/80agjz/handmade_hero_zero_50_cycles_cost_abstractions/

	apis e abstra√ß√µes n√£o existem no v√°cuo
	√© necess√°rio sempre considerar ambos os lados: implementa√ß√£o x uso
	√© preciso contexto para tomar decis√£o informada quanto a onde melhor tra√ßar a linha da abstra√ß√£o

	significa que ganhos que abstra√ß√µes trazem s√£o
	- diretamente proporcional √† complexidade que ajudam a esconder
	- inversamente porporcional √† sua superficie de uso (api)
	(deep vs shallow abstrations)

	lente: complexidade vs potencial x esfor√ßo de implementa√ß√£o
	- complexidade: complexidade com a qual estamos lidando
	- potencial: os ganhos que a api nos traz (facilidade, velocidade de itera√ß√£o, seguran√ßa/assertividade, corretude, automatiza√ß√£o)
	- esfor√ßo de implementa√ß√£o: literalmente o trabalho necess√°rio para abstrair algo em uma api

	do que √© feita uma boa api? (o section logo abaixo)

	agora √© a parte pr√°tica? precisamos de exemplos! muitos deles!!!

	depois de citar uns exemplos:
	problema: lembra que abstra√ß√£o serve pra gerenciar complexidade?
	MUITO CUIDADO para acabar ADICIONANDO complexidade ao sistema

	complexidade?
	dois tipos de complexidade:
	- complexidade inerente: propriedades fundamentais do problema que estamos resolvendo
		- √∫nica maneira de reduzi-la √© mudando o problema (o que √© justo as vezes! design!)
	- complexidade acidental: complexidade adicionada por nossa pr√≥pria solu√ß√£o!
		- essa queremos evitar ao m√°ximo!
		- idealmente zero!!
		- geralmente causada por tentar adicionar uma solu√ß√£o que n√£o pertence ao problema em quest√£o!!

----

	o trabalho n√£o √© implementar o que o desginer ou producer pedem,
	mas sim *entender* o problema e ent√£o resolv√™-lo
	- envolve fazer as perguntas certas
	
	reutilizar design √© mais √∫til que reutilizar c√≥digo!
	√†s vezes for√ßar reutiliza√ß√£o de c√≥digo apenas adicionar complexidade sem realmente adicionar valor a quem usa
	- exemplo da `resource collection` gen√©ricas do jogo plataforma em rust que nunca chegou a existir
	- exemplo do `load asset` que recebia um caminho para carregamento e que tamb√©m funcionava como chave de um cache
		- quebrou rapidamente pois assets de fonte tamb√©m precisam do parametro do tamanho da fonte
		- isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
			- carregar e cachear assets
	- comparar com as cole√ß√µes que existem no pepper
		- parecidas por√©m n√£o 100%
		- facil de adicionar propriedades exclusivas e realmente aconteceu!

	** em algum momento citar o post https://ourmachinery.com/post/dig-shallow-graves/
	** em algum momento citar o v√≠deo do velinho palestrando no google sobre design de api
	** em algum momento citar o v√≠deo do rapazinho do numbers falando sobre api e meta-api
	** em algum momento citar o guia de melhores praticas pra contribuintes da godot https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html

	comunicar solu√ß√µes ao inves de features
	- focar apenas em features nos distancia do real problema que devemos solucionar
-->

<section>
	<h2>na verdade, n√£o √© exatamente *apenas* sobre apis...üëÄ
</section>

<section>
	<h1>do que √© feita uma boa api?</h1>
	<ul>
		<li>consciente quanto ao limite de suas abstra√ß√µes
		<li>balan√ßo entre simplicidade e profundidade
		<li>pre-condi√ß√µes, invariantes e p√≥s-condi√ß√µes claras
		<li>implementa√ß√£o intuitiva
	</ul>
</section>

<section>
	<h1>lente
	<h2>complexidade x potencial x esfor√ßo de implementa√ß√£o
</section>

<section>
	<h1>late binding x early binding
</section>

<section>
	<h1>pre-condi√ß√µes, invariantes e p√≥s-condi√ß√µes
</section>

<section>
	<h1>abstra√ß√µes e vazamentos
	<h2>(meta-api vai aqui?)
</section>

<section>
	<h1>resto
	<h2>constness; debugabilidade; estrutura de dados; mem√≥ria e propriedade; desempenho;
</section>

<!--
# API Design

## por que engines?
N√£o seria √≥timo se existisse uma engine que criasse um DeMagnete com ZERO esfor√ßo?
Apenas apertar UM BOT√ÉO e *putf*! Build nova!

Acontece que ela existe! N√≥s a criamos!
Nosso projeto da unity √© uma engine totalmente especializada em buildar DeMagnetes!

Mas por que n√£o existia uma engine assim?

facilidade x controle

## lente
complexidade x potencial x esfor√ßo de implementa√ß√£o

complexidade:
- dificuldade de entender
- m√° integra√ß√£o com o resto do c√≥digo

potencial
- composabilidade
- fun√ß√µes e estruturas ortogonais
- mais casos de uso contemplados

esfor√ßo de implementa√ß√£o
- tempo do programador
- conceitos dif√≠ceis

----

## comunica√ß√£o
Entender bem o caso de uso de quem realmente vai usar a API (outro programador, designer, etc).

## late binding x early binding
No in√≠cio, queremos ter algo funcionando de forma simples.
No final, queremos ter controle total.

## c√≥digo reutiliz√°vel e c√≥digo f√°cil de deletar
A √∫nica forma de criar c√≥digo reutiliz√°vel √© por extra√≠-lo de c√≥digo f√°cil de deletar.

## pre-condi√ß√µes, invariantes e p√≥s-condi√ß√µes
Ser expl√≠cito e documentar!

ex:
- null
	- linguagens mais recentes t√™m esse conceito embutido (rust, zig, kotlin, C#8)
	- C# da unity n√£o tem isso
	- BitStrap: `Option<T>`
- range de valores
- ordem de execu√ß√£o

## abstra√ß√µes
Abstra√ß√µes SEMPRE vazam. O desafio √© escolher onde tra√ßar a linha.

Modelagem de dados N√ÉO precisa seguir um modelo do mundo real.
Siga os dados! Mais importante √© levar em considera√ß√£o o tipo de acesso mais comum.

## simplicidade
Resolver o problema em quest√£o e n√£o mais.
Prototipa√ß√£o ajuda bastante a achar r√°pido o escopo. Escrever c√≥digo para ser jogado fora (E JOGAR FORA MESMO).

Escrever mais c√≥digo que o necess√°rio, POR DEFINI√á√ÉO, apenas aumenta a complexidade da solu√ß√£o.

Diferentes problemas, requerem diferentes solu√ß√µes.
Se o problema muda, a solu√ß√£o tamb√©m muda!

Prototipa√ß√£o existe para entender o problema.
Comunica√ß√£o!
Se voc√™ n√£o entende o problema, a solu√ß√£o vai sofrer junto.

Future proofing n√£o existe!

## constness
Const correctness.
Sempre preferir fun√ß√µes puras quando poss√≠vel.
√â um espectro, tentar sempre empurrar fun√ß√µes pro lado mais puro.

## debugabilidade
Considere debug em sua solu√ß√£o.
Onde est√£o seus dados? S√£o f√°ceis de inspecionar?
√â f√°cil acompanhar os caminhos de c√≥digo por "stepping" no debbugger?

## estrutura de dados
Estruturas sequenciais (arrays) MUITO provavelmente s√£o suficentes pra sua solu√ß√£o.
Processadores s√£o MUITO bons em varrer mem√≥ria linear.
Provavelmente n√£o precisa de um hashmap ali.

## mem√≥ria e propriedade
Quem √© dono da mem√≥ria (recurso)?
Ownership vs Borrowing.

Onde est√° ocorrendo aloca√ß√£o din√¢mica no seu c√≥digo?
√â poss√≠vel evit√°-las? √â poss√≠vel evitar opera√ß√µes em strings? Minimiz√°-las?

C# => preferir structs; reusar cole√ß√µes;
C++ => mem√≥ria stack; temp allocator;

## desempenho
√â um sistema grande? Pervasivo? Muitas entidades?
Onde h√° 1, h√° muitos! Qual o caso comum? √â poss√≠vel operar em quantidades?
√â poss√≠vel agrupar por tipos ao inv√©s de cole√ß√µes heterog√™neas?
√â poss√≠vel multithread/job system?

## exemplos
https://mobile.twitter.com/rygorous/status/1507178315886444544

- dados est√°ticos em scriptable objects
	- j√° fazemos isso!
	- moral: separar dado que n√£o muda/config em arquivos separados pra facilitar altera√ß√£o, organiza√ß√£o e controle

- classe Timer (Holodrive e depois BitStrap)
	- come√ßo era classe com timer e duration e callback
	- depois struct e duration vinha de scriptable object
	- ai reparamo que tamb√©m n√£o precisava de callback
	- hoje eu colapsaria tudo em apenas uma fun√ß√£o tipo o `SmoothDamp` da unity (recebe um `ref float timer` por par√¢metro)
	- moral: n√£o juntar dado com comportamento cedo demais

	- pergunta: `timer > 0.0f && timer -= delta_time_s` ou `timer < duration && timer += delta_time_s`?
		- `timer < duration` permite alterar o `duration` enquanto o timer t√° rolando e continua funcionando como esperado!

- scene config demagnete
	- come√ßou com tentar reaproveitar c√≥digo gen√©rico feito sem necessidade a ser resolvida
	- teve potencial suficiente pra ser poss√≠vel implementar outros tipos de n√≥s posteriormente
- sistema de dialogos neko
	- mudou por quest√£o de usabilidade (alan usou de forma diferente)
	- mudou por entender melhor o problema (passar dialogo localmente x apenas o server passa)
- BitStrap
	- um bando de c√≥digo reutiliz√°vel extra√≠dos de um bando de c√≥digo f√°cil de deletar
-->

