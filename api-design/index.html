<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style.css">
<title>design de apis</title>
</head>
<body>

<section class="main">
    <h1>design de apis</h1>
    <h2>workshop bitcake 2022</h2>

    <footer>
        <p>por @ahvamolessa</p>
    </footer>
</section>

<section>
    <h1>objetivo</h1>
    <h2>refletir ativamente a respeito das decisões que tomamos ao arquitetar nossas soluções</h2>

    <!--
    workshop um pouco filosófico com o intuito de trazer pra frente pensamentos, que possivelmente
    estavam apenas no subconsciente, a respeito de design e abordagem de desenvolvimento de software.
    -->
</section>

<section style="background-image: url(thinker.jpg)">
    <h1><em>api</em> é apresentar <em>abstrações</em> através de uma <em>interface</em></h1>

    <!--
    não é apenas sobre "application programming interface".
    mas sobre interfaces em geral e os lados de quem cria e de quem consome.
    -->
</section>

<section>
    <h1>por que interfaces?</h1>

    <!--
    por que interfaces são importantes e por que falar a respeito?
    é uma forma (comum) de abordar desenvolvimento de software onde
    nós dividimos um problema complexo em camadas e/ou componentes.
    a forma como essa divisão acontece é introduzindo interfaces.
    isso nos permite limitar o raciocínio necessário quanto à resolução de problema
    ao inves de precisar manter um contexto enorme em mente mesmo ao realizar uma simples modificação.
    -->
</section>

<section style="background-image: url(imagination.jpg)">
    <h1>abstrações</h1>

    <!--
    esse ato de encapsular complexidade a fim de simplificar seu uso é abstrair.
    interfaces estão intrinsicamente relacionada a abstrações.
    e abstrações são fundamentais ao gerenciamento de complexidade
    -->
</section>

<section style="background-image: url(complexity.jpg)">
    <h1>é um modelo com o propósito de interpretar uma realidade rica em detalhes</h1>
    <h2>alcançado por introduzir conceitos pertinentes ao domínio</h2>

    <!--
    nossa maior ferramenta para lidar com complexidade.
    a base inteira de computação é feita por cima de camadas que abstraem detalhes cada vez mais baixo nível.
    
    uma abstração apenas pode ser criada por associar um conceito do domínio em questão aos detalhes que desejamos esconder.
    muitas vezes criando conceitos novos no processo.
    -->
</section>

<section style="background-image: url(faca-dois-legumes.jpg)">
    <h1>abstrair = faca de dois legumes</h1>
    <h2>esconder complexidade <em>adiciona</em> complexidade</h2>

    <!--
    abstrair significa esconder detalhes adicionando presunções implícitas (contexto) que
    quem interagir com tal abstração deve estar a par.
    
    exemplo mais básico desse processo é dar nome a coisas. um nome carrega conceito e significado.
    por conta disso, uma abstração nova sempre vai pelo menos aumentar a carga cognitiva de um sistema.
    
    porém sua vantagem está em justamente criar uma nova forma (supostamente mais simples)
    de raciocinar a respeito de um problema ou sistema.
    é um instrumento de comunicação. uma ferramenta.
    -->
</section>

<section>
    <h1>abstrair != remover complexidade</h1>
    <h2>esconder significa que ainda está lá</h2>

    <!--
    importantíssimo lembrar que os detalhes ainda estão lá!
    abstrair não significa que eles deixam de existir ou que podemos ignorá-los completamente.
    -->
</section>

<section>
    <h1>problemas complexos são complexos</h1>
    <p>a única maneira de simplificar um problema inerenentemente complexo é resolvendo outro problema (que seja mais simples)</p>

    <!--
    resolver outro problema pode significar mudar o design (e tudo bem)!
    
    nosso trabalho não é implementar o que o desginer ou producer pedem,
    mas sim *entender* o problema e então resolvê-lo
    fazer as perguntas certas!
    comunicação! entender o problema!
    -->
</section>

<section>
    <h2>escrever mais código que o necessário <em>por definição</em> apenas aumenta a complexidade da solução</h2>

    <footer>
        <p><a href="http://number-none.com/blow/john_carmack_on_inlined_code.html">john carmack on inlined code</a></p>
    </footer>

    <!--
    tentar quebrar o problema em pedaços menores não remove complexidade
    criar mais classes não o torna mais simples
    criar mais funções não o torna mais simples
    (inclusive pode apenas dificultar o entendimento da solução e, por consequência, da api)
    -->
</section>

<section>
    <h1>complexidade inerente vs complexidade acidental</h1>
    <h2>inerente</h2>
    <ul>
    <li>propriedades fundamentais do problema</li>
    <li>única maneira de reduzi-la é mudando o problema (e tudo bem!)</li>
    </ul>
    <h2>acidental</h2>
    <ul>
    <li>adicionada por nós mesmos</li>
    <li>idealmente zero</li>
    <li>limitações (linguagem, plataforma, design)</li>
    </ul>

    <!--
    todo problema possui uma complexidade inerente.
    qualquer complexidade extra é acidental e deve ser ativamente minimizada.
    PRECISAMOS refletir honestamente se não estamos inconscientemente adicionando complexidade acidental ao sistema!
    -->
</section>

<section>
    <h1>como saber qual complexidade estamos introduzindo?</h1>
    <ul>
    <li>entender o problema</li>
    <li>prototipação</li>
    <li>testar soluções diferentes. refatorar</li>
    <li>evitar grandes soluções genéricas</li>
    <li>evitar future proofing ("fool's errand")</li>
    </ul>
    <p>erros e limitações serão encontrados independente da quantidade de design investido a priori. aceite-os e planeje-se!</p>

    <footer>
        <p><a href="https://ourmachinery.com/post/dig-shallow-graves/">dig shallow graves</a></p>
        <p><a href="https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html">best practices for godot engine contributors</a></p>
    </footer>

    <!--
    entender o problema é fundamental.
    prototipação é como se entende o problema!
    comunicação! comunicação com quem vai usar o sistema. quais são suas reais necessidades?
    a única maneira de acertar um bom design de primeira é com muita sorte ou ter experiência prévia resolvendo tal problema.
    é sobre a jornada! prototipar, iterar e refatorar!
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>sistema de diálogo neko</h1>
    <img src="dialog-before.png" />
    <p>começou super flexível porém laborioso</p>

    <!--
    foi inclusive latente o problema de usabilidade
    uma vez que o alan tentou abstrair a flexibilidade do sistema
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>sistema de diálogo neko</h1>
    <img src="dialog-after.png" />
    <p>reconhecendo o caso comum, otimizamos o processo</p>

    <!--
    entendendo melhor a forma como o sistema seria usado,
    foi possível otimizar a usabilidade
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>sistema de diálogo neko</h1>
    <img src="dialog-implementation.png" />
    <p>inclusive, a forma simples é implementada por cima da flexível</p>

    <!--
    assim a gente ainda tem a opção de ter controle total quando necessário
    mantendo a facilidade de uso para o caso comum: posicionar camera + sequência de diálogo
    
    importante entender que ainda existe tradeoff que é uma carga cognitiva maior
    por ter mais opções e mais funcionalidades em geral
    -->
</section>

<section>
    <h1>código reutilizável vs código fácil de deletar</h1>
    <h2>a única forma de criar código reutilizável é extraindo-o de código fácil de deletar</h2>

    <footer>
        <p><a href="https://caseymuratori.com/blog_0015">semantic compression</a></p>
        <p><a href="https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems">how to write disposable code in large systems</a></p>
    </footer>

    <!--
    código fácil de deletar é aquele que outros não dependem
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>bitstrap (umake)</h1>
    <img src="umake.png" />
    <p>umake v2 vs v3</p>

    <!--
    bitstrap nada mais é que um bando de código reutilizável extraídos de um bando de código fácil de deletar
    
    (repara nas referências fixas na v2)
    
    ex: scene config demagnete
    - começou com tentar reaproveitar código genérico feito sem necessidade a ser resolvida
    - teve potencial suficiente pra ser possível implementar outros tipos de nós posteriormente
    -->
</section>

<section>
    <h1>apesar de tudo, abstrações vazam</h1>
    <h2>sem exceção</h2>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=5l2wMgm7ZOk">why black boxes are so hard to reuse</a></p>
    </footer>

    <!--
    acontece que abstrações infelizmente têm essa propriedade de inevitavelmente vazar detalhes de sua implementação.
    não importa o quão boa é uma abstração. ela vaza detalhes de alguma forma.
    
    ou seja: não existe abstração perfeita. alguma coisa sempre se perde.
    e pode acontecer até de ter um ganho negativo: a abstração deixa o sistema em geral mais complexo do que seria sem ela.
    
    ex de abstracao:
    - carro manual => passar marcha é um vazamento da implementação do carro (como funciona internamente)
    - carro automatico => não é 100% pois ainda existem `1`, `2`, `P`, além do `D`
    - mesmo que fosse "100%", ainda existe manutenção => precisa entender quando precisa levar ao mecânico, checar agua, oleo, etc
    -->
</section>

<section>
    <h1>abstrações apenas têm valor quando levantam seu próprio peso</h1>
    <h2>"programmers know the benefits of everything and the tradeoffs of nothing"</h2>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ">there are no zero-cost abstractions</a></p>
        <p><a href="https://www.youtube.com/watch?v=rI8tNMsozo0">simplicity matters</a></p>
    </footer>

    <!--
    importante pra nos lembrar dos custos de adicionar abstrações a um sistema nos guia a onde traçamos apis.
    
    lembrar que no inicio, queremos super agilidade, porém no final, queremos total controle.
    -->
</section>

<section>
    <h1>apis e abstrações <em>não</em> existem no vácuo</h1>
    <ul>
    <li>o que: abstrações</li>
    <li>intenção de uso: interface</li>
    <li>quem usa: comunicação</li>
    <li>restrições: linguagem, plataforma, inércia dos códigos já existentes</li>
    </ul>

    <footer>
        <p><a href="https://cellperformance.beyond3d.com/articles/2006/04/performance-and-good-data-design.html">performance and good data design</a></p>
        <p><a href="https://quuxplusone.github.io/blog/2022/06/23/unordered-multiset-equal-range/">c++: unordered_multiset's api affects its big-o</a></p>
    </footer>

    <!--
    - o que: custos de abstração
    - intenção de uso: uso da api é tão importante quanto sua implementação
    - quem usa: entender o problema. as reais necessidades de quem vai usar a api
    - restrições: o que a gente tem pra trabalhar. alvos de desempenho, etc. códigos já escritos que irão interagir com o sistema novo
    
    tomar decisão informada quanto a onde traçamos a linha da abstração
    -->
</section>

<section class="main">
    <h1>uma api é boa se ela é <em>profunda</em> e possui <em>interface enxuta</em></h1>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=bmSAYlu0NcY">a philosophy of software design</a></p>
    </footer>

    <!--
    enfim do que é feita uma boa api!
    criar abstrações que adicionam valor substancial ao sistema, à solução e aos usuários.
    -->
</section>

<section style="background-image: url(granularity.jpg)">
    <h1>granularidade</h1>
    <p>abstrações acontecem em vários níveis, mas o potencial é proporcional à escala</p>

    <!--
    níveis: nome, função, classe, módulo, programa, sistema, etc.
    temos mais potencial de profundidade quanto maior a escala.
    
    realidade: classes são granulares demais para promoverem sozinhas uma api profunda.
    
    isso nos induz a manter interfaces permissivas e flutuantes entre classes de um mesmo módulo/sistema.
    e deixar pra implementar interfaces formais e impenetráveis de api a nível de módulos no mínimo.
    
    na prática: encapsulamento (getter/setter, variáveis e funções privadas/protegidas, arquivos super fragmentados, etc)
    não são importantes enquanto estamos no mesmo módulo.
    é tudo parte de uma mesma implementação: a abstração principal do sistema.
    -->
</section>

<section>
    <h1>profunda</h1>
    <ul>
    <li>ortogonal</li>
    <li>composível</li>
    <li>complexidade adicionada < complexidade abstraída</li>
    <h1>interface enxuta</h1>
    </ul>
    <ul>
    <li>padrões razoáveis</li>
    <li>estado mínimo</li>
    <li>invariantes explícitas</li>
    <li>intui sua implementação</li>
    </ul>
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>ortogonal</h1>
    <img src="orthogonal.png" />
    <p>conceitos são independentes e não se influenciam</p>

    <!--
    conceitos são ortogonais até não serem mais
    -->
</section>

<section>
    <p>ortogonal</p>
    <h1>altura do pulo ❌</h1>
    <img src="jump-config.png" />
    <img src="gravity-config.png" />
    <img src="stick-config.png" />

    <!--
    tanto mudar impulso de pulo quanto gravidade influenciam altura do pulo
    mais ainda: quando o gato tá grudado a um prop, o peso do prop e os multiplicadores também influenciam
    -->
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>composível</h1>
    <p>quão fácil é a interação com outras abstrações?</p>
    <p>(mais prático quando há um canal uniforme que integra sistemas)</p>

    <!--
    um pouco menos prático para os nossos casos já que costumamos fazer sistemas especializados.
    algo a se levar em conta ao analizar códigos de terceiros.
    -->
</section>

<section>
    <p>composível</p>
    <h1>narrow waist</h1>
    <p>exemplo: unix pipeline</p>
    <pre><code>ls -l | grep key | less</code></pre>

    <footer>
        <p><a href="https://www.oilshell.org/blog/2022/03/backlog-arch.html">a sketch of the biggest idea in software architecture</a></p>
    </footer>

    <!--
    faca de dois legumes: facilita a comunicação entre sistemas, limita a comunicação entre sistemas
    -->
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <p>composível</p>
    <h1>late binding x early binding</h1>
    <p>no início, queremos simplicidade</p>
    <p>no final, queremos controle total</p>

    <!--
    "binding" é um conceito que vem de programação funcional. basicamente significa dar um nome a um valor (to bind).
    "late binding" era uma das propostas de alan kay em sua visão para orientação a objetos realizada em smalltalk.
    a linguagem deixa pra decidir no último momento qual o valor que um nome tem.
    temos reflexo disso em funções virtuais + overloading em que o código que será executado só é sabido na hora da chamada.
    
    não é bom nem ruim por si só. depende do contexto.
    
    late binding dá flexibilidade porém dificulta validação. e vice-versa para early binding.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>late binding dialogo neko</h1>
    <pre><code>class UNekoDialogueCharacterDataAsset : public UDataAsset {
    ENekoDialogueCharacterId Id = ENekoDialogueCharacterId::None;

    TArray&ltTSoftObjectPtr&ltUTexture2D&gt&gt Expressions;

    // implementado com for
    UTexture2D* GetExpression(ENekoDialogueCharacterExpression Expression);
};</code></pre>

    <!--
    todas as expressões ficam no array expressions.
    teoricamente temos flexibilidade pra configurar as expressões,
    mas na prática, todos os personagems vão ter as mesmas entradas.
    fácil esquecer ou duplicar uma expressão por não ter validação.
    
    `GetExpression` é um `for` que busca uma entrada em `Expressions` que seja do tipo `Expression`. operação falível.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>early binding dialogo neko</h1>
    <pre><code>class UNekoDialogueCharacterDataAsset : public UDataAsset {
    ENekoDialogueCharacterId Id = ENekoDialogueCharacterId::None;

    TSoftObjectPtr&ltUTexture2D&gt ExpressionDefault;
    TSoftObjectPtr&ltUTexture2D&gt ExpressionAngry;
    TSoftObjectPtr&ltUTexture2D&gt ExpressionHappy;

    // implementado com switch
    UTexture2D* GetExpression(ENekoDialogueCharacterExpression Expression);
};</code></pre>

    <!--
    agora listamos todas as expressões explicitamente.
    impossível duplicar. esquecer uma expressão significa ter um buraco vazio no editor.
    
    `GetExpression` agora é um `switch` que é implementado na mão. porém agora é uma operação infalível.
    -->
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>complexidade adicionada < complexidade abstraída</h1>
    <p>abstrações devem puxar mais que seu próprio peso</p>
    <p>entender os tradeoffs feitos</p>
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <p>complexidade adicionada < complexidade abstraída</p>
    <h1>desempenho</h1>
    <ul>
    <li>é um sistema pervasivo? muitas entidades?</li>
    <li>onde há um, há muitos! qual o caso comum? operar em lotes!</li>
    <li>agrupar por tipos ao invés de coleções heterogêneas</li>
    <li>particionar ao invés de branch</li>
    <li>multithread? job system?</li>
    </ul>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>padrões razoáveis</h1>

    <!--
    criar um "pit of success" pra quem for usar
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>padrões razoáveis</p>
    <h1>"data driven"</h1>
    <p>extrair dados estáticos em arquivos separados</p>
    <ul>
    <li>unity: scriptable objects</li>
    <li>unreal: data asset</li>
    </ul>

    <!--
    separar dado que não muda/config em arquivos separados pra facilitar alteração, organização e controle
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>padrões razoáveis</p>
    <h1>estruturas de dados</h1>
    <p>arrays <em>muito</em> provavelmente são suficientes</p>
    <p>processadores adoram memória linear</p>
    <p>*olha feio praquela lista encadeada* 😠</p>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>estado mínimo</h1>
    <p>sobre quais os dados a api opera?</p>
    <p>onde eles são alterados?</p>

    <footer>
        <p><a href="https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-">in detph: functional programming in c++</a></p>
        <p><a href="https://mobile.twitter.com/rygorous/status/1507178315886444544">twitter - sobre estado</a></p>
    </footer>

    <!--
    não é sobre anarquia! :B
    facilitar entendimento e reflexão por diminuir "partes móveis".
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>estado mínimo</p>
    <h1>const correctness</h1>
    <p>preferir estilo funcional sempre que possível</p>
    <p>facilita compreensão. menos dependente de ordem de execução</p>
    <pre><code>// evitar
obj.CheckSomething();
obj.MaybeDoSomethingInResponse();

// preferir
var result = obj.CheckSomething();
if (result) {
    obj.DoSomethingInResponse(result);
}</code></pre>

    <footer>
        <p><a href="https://isocpp.org/wiki/faq/const-correctness">c++ const correctness</a></p>
    </footer>

    <!--
    as linhas serem breves são um falso indicador da complexidade por trás uma vez que
    para realmente entender o que está acontecendo, agora devemos ter em mente o estado interno de `obj`.
    mudar a ordem das linhas ou esquecer uma delas facilmente causará bugs.
    
    aqui `CheckSomething` não modifica o estado interno de obj e apenas retorna o resultado calculado.
    enquanto `DoSomethingInResponse` explicitamente age em cima do resultado obtido.
    também está explícito o `if` que antes estava escondido em `MaybeDoSomethingInResponse`.
    
    ex: maquina de estados opengl.
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>estado mínimo</p>
    <h1>recursos e posse</h1>
    <p>quem é o responsável pelo recurso?</p>
    <p>posse vs empréstimo</p>
    <p>onde há alocação de memória? possível evitá-la?</p>
    <ul>
    <li>c# = preferir structs e arrays; reusar coleções</li>
    <li>c++ = arrays; inline allocator;</li>
    </ul>

    <footer>
        <p><a href="https://docs.microsoft.com/en-us/dotnet/standard/memory-and-spans/memory-t-usage-guidelines#owners-consumers-and-lifetime-management">c# memory and spans - owners, consumers and lifetime management</a></p>
        <p><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L25">List.cs</a></p>
        <p><a href="https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Containers/TInlineAllocator/">TInlineAllocator</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>invariantes explícitas</h1>
    <p>+ pré-condições</p>
    <p>+ pós-condições</p>

    <!--
    uma propriedade do sistema que é sempre verdade.
    ex: esse ponteiro sempre aponta para memória válida.
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>invariantes explícitas</p>
    <h1>null</h1>
    <p>pré-condição: quais funções podem <em>receber</em> null?</p>
    <p>pós-condição: quais funções podem <em>retornar</em> null?</p>
    <p>decidir e ser explícito!</p>
    <p>linguagens mais recentes têm esse conceito embutido (rust, zig, kotlin, c#8)</p>
    <ul>
    <li>c# da unity não tem isso</li>
    <li>bitstrap: <code>Option<T></code></li>
    </ul>

    <footer>
        <p><a href="https://github.com/bitcake/bitstrap/blob/master/Assets/Runtime/Functional/Option.cs">Option.cs</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>invariantes explícitas</p>
    <h1>minimizar erros</h1>
    <p>dois tipos de erros:</p>
    <ul>
    <li>entrada/saída => tratar</li>
    <li>lógica => assert</li>
    </ul>

    <footer>
        <p>"define errors out of existence" -- ousterhout, john</p>
        <p><a href="https://nullprogram.com/blog/2022/06/26/">assertions should be more debugger-oriented</a></p>
    </footer>

    <!--
    qualquer outro tipo de erro é desnecessário
    
    TODO: expandir exemplo
    ex: pepper CommandTokenizer
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h2>intervalo de valores</h2>
    <p>usar tipos para codificar valores válidos</p>
    <pre><code>// evitar
int GetPlayerCount();

// preferir
uint8 GetPlayerCount();</code></pre>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>intui sua implementação</h1>
    <p>a partir de uma transformação conhecida, é possível inferir aproximadamente suas entradas e saídas</p>

    <!--
    quando nos dispomos a implementar um sistema, intuitivamente devemos ter noção da forma de suas entradas e saídas.
    da mesma forma quando vamos consumir uma api que se propõe a resolver um determinado problema,
    temos uma noção do que esperar de sua interface.
    
    ex: api para baixar arquivo (url)
    ex: api para desenhar retângulo (x, y, w, h, color)
    
    em cada um dos exemplos, dá pra se aprofundar em mais detalhes:
    http vs ftp vs tcp/ip; rotação, tamanho borda, gradiente vs textura; etc.
    
    porém o importante é que ainda assim, o formato das entradas e saídas ainda se assemelham ao intuido.
    se, por outro lado, a interface diverge demais do esperado, é provável que não seja uma boa api.
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>intui sua implementação</p>
    <h1>debugabilidade</h1>
    <ul>
    <li>onde estão os dados?</li>
    <li>são fáceis de inspecionar?</li>
    <li>é fácil acompanhar o que está acontecendo pelo debugger?</li>
    </ul>
</section>

<section style="background-image: url(galaxy-brain.png)">
    <h1>às vezes não precisa de api ou abstração</h1>
    <h2>código vai, design fica</h2>

    <!--
    nosso trabalho é resolver problema. escrever código é consequência.
    
    reutilizar design é mais útil que reutilizar código!
    às vezes forçar reutilização de código apenas adicionar complexidade sem realmente adicionar valor a quem usa
    
    TODO: expandir exemplo?
    - exemplo da `resource collection` genéricas do jogo plataforma em rust que nunca chegou a existir
    - exemplo do `load asset` que recebia um caminho para carregamento e que também funcionava como chave de um cache
        - quebrou rapidamente pois assets de fonte também precisam do parametro do tamanho da fonte
        - isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
            - carregar e cachear assets
    - comparar com as coleções que existem no pepper
        - parecidas porém não 100%
        - facil de adicionar propriedades exclusivas e realmente aconteceu!
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe AssetLoader</h1>
    <pre><code>pub trait Asset: Sync + Send + 'static {
    type Id: fmt::Debug + Hash + Eq + Clone + Sync + Send;
}
pub trait AssetLoader&lt'a, A: Asset&gt {
    type Storage;
    fn load(&'a self, id: &A::Id, storage: &mut Self::Storage) -&gt Result&ltA, AssetLoadError&gt;
}
pub fn try_load&lt'a, S&gt(
    &mut self,
    id: &A::Id,
    loader: &'a AssetLoader&lt'a, A, Storage = S&gt,
    storage: &mut S,
) -&gt Result&ltAssetHandle&ltA&gt, AssetLoadError&gt {
    match self.cache_map.get(id).cloned() {
        Some(handle) =&gt Ok(handle),
        None =&gt {
            let asset = loader.load(id, storage)?;
            let handle = self.add(asset);
            self.cache_map.insert(id.clone(), handle);
            Ok(handle)
        }
    }
}</code></pre>

    <!--
    começou como uma abstração template pra carregar assets de vários tipos a partir de um path.
    até que chegamos em fontes, que precisam de um path + font-size. quebrou a abstração precoce!
    acontece que eu continuei no caminho da abstração criando mais camadas adicionando mais templates
    se distanciando cada vez mais da solução do problema: carregar assets do disco.
    
    enquanto isso, a solução basicamente *pedia* que fosse separada em várias structs ao inves de uma genérica.
    anos depois quando fui programar meu editor de código, não cai na mesma armadilha e separei as coleções de
    Buffers, BufferViews, Plugins e Clients (todas têm um Handle associado).
    Dessa forma, é super fácil de adicionar funcionalidade própria de cada coleção sem influenciar ou estar amarrado
    às outras coleções.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe timer v1</h1>
    <pre><code>public class Timer { // holodrive
    [SerializeField] private float length = 1.0f; // serializado
    private float counter = 0.0f;
    public System.Action OnTimer { get; set; } // callback

    public void OnUpdate() {
        if( counter &lt 0.0f ) {
            // Already triggered callback.
        } else if( counter &lt length ) {
            counter += Time.deltaTime;
        } else {
            counter = -1.0f;
            if( OnTimer != null )
                OnTimer();
        }
    }
}</code></pre>

    <!--
    vários detalhes omitidos
    clássica implementação orientada a objetos
    
    `length` é serializado no MonoBehaviour
    callbacks são configurados no Start/Awake
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe timer v2</h1>
    <pre><code>public sealed class Timer { // demagnete
    public float length = 1.0f; // dinamico
    private float elapsedTime = -1.0f;

    public bool OnUpdate() { // sem callback
        if( elapsedTime &gt= 0.0f )
            elapsedTime += Time.deltaTime;
        if( elapsedTime &lt length ) {
            elapsedTime = -1.0f;
            return true;
        }
        return false;
    }
}</code></pre>

    <!--
    quase sempre o que a gente queria, na verdade, era configurar a duração do timer em um ScriptableObject.
    igualmente, os callbacks costumavam ser bem curtos. suas declarações eram ruído.
    
    antes de iniciar o timer, muda o valor de `length` com base num ScriptableObject.
    api "immediate mode" aproveitando que `OnUpdate` já precisava ser chamado todo frame.
    código do callback inline dentro de um `if`. bem mais fácil de acompanhar os caminhos de código.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe timer v3</h1>
    <pre><code>float Timer = -1.0f; // neko
// ...
void AMyActor::Tick(float DeltaSeconds) {
    if (Timer &gt= 0.0f) {
        Timer += DeltaSeconds;
        if (Timer &gt= Config-&gtTimerDuration) {
            // do the thing!
            Timer = -1.0f;
        }
    }
}</code></pre>

    <!--
    em sua última iteração, não existe mais classe timer.
    agora é apenas um idioma. um padrão que emerge nos códigos.
    adicionar uma classe apenas aumentaria a complexidade com ganhos ínfimos.
    não há mais a necessidade de abstrair.
    
    para começar o timer, é só fazer `Timer = 0.0f`.
    
    bonus: reparar que é possível aumentar o `TimerDuration` enquanto o timer está rodando e continua funcionando.
    -->
</section>

<section class="main">
    <h1>3 big lies</h1>
    <ul>
    <li>software is a platform</li>
    <li>code should be designed around a model of the world</li>
    <li>code is more important than data</li>
    </ul>

    <footer>
        <p><a href="https://cellperformance.beyond3d.com/articles/2008/03/three-big-lies.html">three big lies</a></p>
    </footer>

    <!--
    software is a platform
    - hardware é a platforma
    - pra nos lembrar das implicações de desempenho que nossas abstrações implicam
    
    code should be designed around a model of the world
    - dados e suas transformações devem guiar o design
    - pre-mapear relações e conceitos de mundo em uma solução apenas adiciona ruido e restrições desnecessárias
        - e, portanto, dificulta chegar ao melhor design
    
    code is more important than data
    - dados são mais importantes
    - código não existe pra ser bonito. a solução não existe pra ser bonita. ambos existem pra resolver o problema
    - as apis devem refletir isso. elas *precisam* resolver o problema e nada mais.
        - caso contrario apenas adicionam complexidade acidental ao sistema
    -->
</section>

<section>
    <h1>design de api = ponderar custo-benefícios</h1>
    <p>"everything should be made as simple as possible, but not simpler."</p>
    <p>-- einstein, albert (supostamente)</p>

    <footer>
        <p>valeu! falou! :)</p>
    </footer>

    <!--
    "tudo deve ser feito o mais simples possível, porém não mais simples que isso."
    
    uma solução que poderia ser mais simples possui desperdício.
    uma solução que é simples demais ignora detalhes importantes.
    
    é através de simplicidade que atingimos apis balanceadas entre custo e benefício
    -->
</section>

</body>
</html>
