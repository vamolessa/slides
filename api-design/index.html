<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style.css">
<title>design de apis</title>

<main>
	<h1>design de apis
	<h2>workshop bitcake 2022
</main>

<section style="background-image: url(thinker.jpg)">
	<h1><em>api</em> é apresentar uma ou mais <em>abstrações</em> através de uma <em>interface</em>
</section>
<!--
intrinsicamente relacionada a abstrações
fundamental ao gerenciamento de complexidade
-->

<main>
	<h1>uma api é boa se ela é <em>profunda</em> e possui <em>interface enxuta</em>
</main>
<!--
esse é o âmago da ideia
criar abstrações que adicionam valor ao software em questão porém que contribuem minimamente ao aumento de sua complexidade
-->

<section>
	<h1>profunda</h1>
	<ul>
		<li>ortogonal
		<li>composível
		<li>complexidade adicionada < complexidade abstraída
		<li>vazamento mínimo
	</ul>

	<h1>interface enxuta</h1>
	<ul>
		<li>padrões razoáveis
		<li>estado mínimo e explícito
		<li>pré-condições + invariantes + pós-condições
		<li>intui sua implementação
	</ul>
</section>
<!--
ortogonal = conceitos não se sobrepõem. configurar um conceito não influencia outro
composível = é permitido e talvez até fácil de interagir com outras abstrações
adicionada < abstraída = puxar mais que seu próprio peso
vazamento mínimo

padrões razoáveis = criar um "pit of success" pra quem for usar
estado mínimo = é implementação porém vaza facilmente. ex: ordem de execução
condições + invariantes = explicidade. também gerenciamento de erros
	Const correctness.
	Sempre preferir funções puras quando possível.
	É um espectro, tentar sempre empurrar funções pro lado mais puro.

	ex:
	- null
		- linguagens mais recentes têm esse conceito embutido (rust, zig, kotlin, C#8)
		- C# da unity não tem isso
		- BitStrap: `Option<T>`
	- range de valores
	- ordem de execução
intui implementação = faz parte da interface saber (pelo menos) superficialmente sobre sua implementação!
-->

<section style="background-image: url(imagination.jpg)">
	<h1>abstrações
	<h2>é o ato de esconder complexidade
</section>
<!--
razoável porém importantíssimo lembrar que a complexidade ainda está lá (mais sobre isso depois)
-->

<section style="background-image: url(complexity.jpg)">
	<header>abstrações</header>
	<h1>é um modelo com o propósito de interpretar uma realidade complexa e rica em detalhes
	<h2>e isso é feito introduzindo conceitos pertinentes ao domínio
</section>
<!--
nossa maior ferramenta para lidar com complexidade
a base inteira de computação é feita por cima de camadas que abstraem detalhes cada vez mais baixo nível

uma abstração apenas pode ser criada por associar um conceito do domínio do problema em questão
aos detalhes que desejamos esconder. isso muitas vezes criando conceitos novos no processo.

exemplo mais básico desse processo é dar nome a coisas.
por conta disso, uma abstração nova sempre vai pelo menos aumentar a carga cognitiva de um sistema

porém sua vantagem está em justamente criar uma nova forma (supostamente mais simples) de raciocinar a respeito de um problema
é um instrumento de comunicação no final das contas
-->

<section style="background-image: url(flextape.jpg)">
	<header>abstrações</header>
	<h1>porém abstrações vazam
	<h2>sem exceção
	<footer>
		<a href="https://www.youtube.com/watch?v=5l2wMgm7ZOk">why black boxes are so hard to reuse</a>
	</footer>
</section>
<!--
acontece que abstrações infelizmente têm essa propriedade de inevitavelmente vazar detalhes de sua implementação

ou seja: não existe abstração perfeita. sempre se perde alguma coisa. e pode acontecer até de ter um ganho negativo:
a abstração deixa o sistema em geral mais complexo do que seria sem ela.

exemplo do carro? (marchas, etc)
também adicionam complexidade!
precisam levantar seu próprio peso!
-->


<!--
toda adição de conceito ao sistema o torna mais complexo.

toda nome é uma abstração. (talvez juntar na parte que fala sobre nomes também?)

"Everything should be made as simple as possible, but not simpler."
- Einstein. Supostamente

complexidade acidental vs complexidade inerente

como saber qual complexidade estamos introduzindo?
- entender o problema
- iteração de implementação E design
- não tentar future proofing ("fool's errand")
- não ter medo de refatorar e testar soluções diferentes
- erros e limitações serão encontrados independente da quantidade de design investido a priori. aceite-os

-->

<!--
problemas complexos são complexos!

tentar quebrá-lo em pedaços menos não o torna mais simples
criar mais classes não o torna mais simples
criar mais funções não o torna mais simples
(inclusive pode apenas dificultar o entendimento da solução e, por consequência, da api)

escrever mais código que o necessário, POR DEFINIÇÃO, apenas aumenta a complexidade da solução.

a única maneira de simplificar um problema inerentemente complexo é resolvendo outro problema (que seja mais simples)
-->

<!--
às vezes não precisa de api/abstração

nosso trabalho é resolver problema. escrever código é consequência.

3 big lies
- code is platform
	- hardware é a platforma
	- pra nos lembrar das implicações de desempenho que nossas abstrações implicam
- code should be modeled after the world
	- dados e suas transformações devem guiar o design
	- pre-mapear relações e conceitos de mundo em uma solução apenas adiciona ruido e restrições desnecessárias
		- e, portanto, dificulta chegar ao melhor design
- code is more important than data
	- dados são mais importantes
	- código não existe pra ser bonito. a solução não existe pra ser bonita. ambos existem pra resolver o problema
	- as apis devem refletir isso. elas *precisam* resolver o problema e nada mais.
		- caso contrario apenas adicionam complexidade acidental ao sistema

-->

<!--
# iteração

## código reutilizável e código fácil de deletar
A única forma de criar código reutilizável é por extraí-lo de código fácil de deletar.

Diferentes problemas, requerem diferentes soluções.
Se o problema muda, a solução também muda!

Prototipação existe para entender o problema.
Comunicar com quem irá usar o sistema.

Se você não entende o problema, menos chances de implementar uma boa solução

-->

<!--
# outros

## late binding x early binding (fica aqui mesmo???)
No início, queremos ter algo funcionando de forma simples.
No final, queremos ter controle total.

## debugabilidade
Considere debug em sua solução.
Onde estão seus dados? São fáceis de inspecionar?
É fácil acompanhar os caminhos de código por "stepping" no debbugger?

## estrutura de dados
Estruturas sequenciais (arrays) MUITO provavelmente são suficentes pra sua solução.
Processadores são MUITO bons em varrer memória linear.
Provavelmente não precisa de um hashmap ali.

## memória e propriedade
Quem é dono da memória (recurso)?
Ownership vs Borrowing.

Onde está ocorrendo alocação dinâmica no seu código?
É possível evitá-las? É possível evitar operações em strings? Minimizá-las?

C# => preferir structs; reusar coleções;
C++ => memória stack; temp allocator;

## desempenho
É um sistema grande? Pervasivo? Muitas entidades?
Onde há 1, há muitos! Qual o caso comum? É possível operar em quantidades?
É possível agrupar por tipos ao invés de coleções heterogêneas?
É possível multithread/job system?

-->











<!--
	TODAS abstrações vazam!!
	escolher onde tracar a linha da abstração
	ex de abstracao:
	- carro manual => passar marcha é um vazamento da implementação do carro (como funciona internamente)
	- carro automatico => não é 100% pois ainda existem `1`, `2`, `P`, além do `D`
	- mesmo que fosse "100%", ainda existe manutenção => precisa entender quando precisa levar ao mecânico, checar agua, oleo, etc
	- toda abstração vaza detalhes de implementação!
		- e tudo bem! isso não invalida suas utilidades
		- porem, existe um gradiente aí! mesmo sempre existindo vazamento, é de nosso interesse minimizá-lo!!
		- https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ&index=11

	importante: escolher onde traça a linha de abstração
		- escolher o que é abstraido e o que é exposto
		- ser consciente quanto a isso!
	lembrar sempre qual a razão da existência das abstrações: esconder detalhes/gerenciar complexidade
	IMPORTANTE: os detalhes e sua complexidade AINDA ESTÃO LÁ e não devemos ignorá-los!

	faca de dois legumes: abstrair significa esconder detalhes adicionando contexto implicíto
	se quem vai usar api não estiver a par desse contexto implícito... coisas ruins podem acontecer :')
	ex: mike conversa naturalmente com lucas, dustin e will.
	mas às vezes tem dificuldade com a eleven às vezes tendo que explicar conceitos
	que outrora fossem básicos e esperados que todos o tivessem

	https://www.reddit.com/r/programming/comments/80agjz/handmade_hero_zero_50_cycles_cost_abstractions/

	apis e abstrações não existem no vácuo
	é necessário sempre considerar ambos os lados: implementação x uso
	é preciso contexto para tomar decisão informada quanto a onde melhor traçar a linha da abstração

	agora é a parte prática? precisamos de exemplos! muitos deles!!!

	depois de citar uns exemplos:
	problema: lembra que abstração serve pra gerenciar complexidade?
	MUITO CUIDADO para acabar ADICIONANDO complexidade ao sistema

	complexidade?
	dois tipos de complexidade:
	- complexidade inerente: propriedades fundamentais do problema que estamos resolvendo
		- única maneira de reduzi-la é mudando o problema (o que é justo as vezes! design!)
	- complexidade acidental: complexidade adicionada por nossa própria solução!
		- essa queremos evitar ao máximo!
		- idealmente zero!!
		- geralmente causada por tentar adicionar uma solução que não pertence ao problema em questão!!

----

	iteração
	adições ou modificações devem ser feitas de tal modo que o produto final seja idealmente
	o mesmo caso o sistema inteiro fosse feito do zero com o conhecimento de dominio atual
	- não ter medo de refatoração ao inves de apenas tentar encaixar funcionalidade nova sem mexer muito no que já está lá

	o trabalho não é implementar o que o desginer ou producer pedem,
	mas sim *entender* o problema e então resolvê-lo
	- envolve fazer as perguntas certas
	
	reutilizar design é mais útil que reutilizar código!
	às vezes forçar reutilização de código apenas adicionar complexidade sem realmente adicionar valor a quem usa
	- exemplo da `resource collection` genéricas do jogo plataforma em rust que nunca chegou a existir
	- exemplo do `load asset` que recebia um caminho para carregamento e que também funcionava como chave de um cache
		- quebrou rapidamente pois assets de fonte também precisam do parametro do tamanho da fonte
		- isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
			- carregar e cachear assets
	- comparar com as coleções que existem no pepper
		- parecidas porém não 100%
		- facil de adicionar propriedades exclusivas e realmente aconteceu!

	** em algum momento citar https://ourmachinery.com/post/dig-shallow-graves/
	** em algum momento citar "A Philosophy of Software Design" https://www.youtube.com/watch?v=bmSAYlu0NcY
	** em algum momento citar "Why Black Boxes are so Hard to Reuse" https://www.youtube.com/watch?v=5l2wMgm7ZOk
	** em algum momento citar o guia de melhores praticas pra contribuintes da godot https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html

	comunicar soluções ao inves de features
	- focar apenas em features nos distancia do real problema que devemos solucionar
-->

<section>
	<h1>late binding x early binding
</section>

<section>
	<h1>pre-condições, invariantes e pós-condições
</section>

<!--
## exemplos
https://mobile.twitter.com/rygorous/status/1507178315886444544

- dados estáticos em scriptable objects
	- já fazemos isso!
	- moral: separar dado que não muda/config em arquivos separados pra facilitar alteração, organização e controle

- classe Timer (Holodrive e depois BitStrap)
	- começo era classe com timer e duration e callback
	- depois struct e duration vinha de scriptable object
	- ai reparamo que também não precisava de callback
	- hoje eu colapsaria tudo em apenas uma função tipo o `SmoothDamp` da unity (recebe um `ref float timer` por parâmetro)
	- moral: não juntar dado com comportamento cedo demais

	- pergunta: `timer > 0.0f && timer -= delta_time_s` ou `timer < duration && timer += delta_time_s`?
		- `timer < duration` permite alterar o `duration` enquanto o timer tá rolando e continua funcionando como esperado!

- scene config demagnete
	- começou com tentar reaproveitar código genérico feito sem necessidade a ser resolvida
	- teve potencial suficiente pra ser possível implementar outros tipos de nós posteriormente
- sistema de dialogos neko
	- mudou por questão de usabilidade (alan usou de forma diferente)
	- mudou por entender melhor o problema (passar dialogo localmente x apenas o server passa)
- BitStrap
	- um bando de código reutilizável extraídos de um bando de código fácil de deletar

-->

