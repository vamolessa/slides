<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style.css">
<title>design de apis</title>

<main>
	<h1>design de apis
	<h2>workshop bitcake 2022
</main>

<section style="background-image: url(thinker.jpg)">
	<h1>...a coisa vai ficar filosófica
</section>

<section>
	<h1>apis são interfaces
	<h2>e interface é partição + comunicação
</section>

<!--
revisar aqui
linkar melhor api a abstrações
-->
<section>
	<h1>do que é feita uma boa api?</h1>

	<ul>
		<li>consciente quanto ao limite de suas abstrações <!-- ??? -->
		<li>interface simples, abstrações profundas
		<li>pre-condições, invariantes e pós-condições claras
		<li>implementação intuitiva
	</ul>
</section>

<section style="background-image: url(imagination.jpg)">
	<h1>abstrações
</section>

<section>
	<header>abstrações</header>
	<h1>abstrair é esconder/gerenciar complexidade
	<h2>mas ela ainda está lá!
</section>

<section style="background-image: url(flextape.jpg)">
	<header>abstrações</header>
	<h1>porém abstrações vazam
	<h2>sem exceção
	<p>exemplo do carro? (marchas, etc)
	<p>também adicionam complexidade!
	<p>precisam levantar seu próprio peso!
</section>



<!--
	TODAS abstrações vazam!!
	escolher onde tracar a linha da abstração
	ex de abstracao:
	- carro manual => passar marcha é um vazamento da implementação do carro (como funciona internamente)
	- carro automatico => não é 100% pois ainda existem `1`, `2`, `P`, além do `D`
	- mesmo que fosse "100%", ainda existe manutenção => precisa entender quando precisa levar ao mecânico, checar agua, oleo, etc
	- toda abstração vaza detalhes de implementação!
		- e tudo bem! isso não invalida suas utilidades
		- porem, existe um gradiente aí! mesmo sempre existindo vazamento, é de nosso interesse minimizá-lo!!
		- https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ&index=11

	importante: escolher onde traça a linha de abstração
		- escolher o que é abstraido e o que é exposto
		- ser consciente quanto a isso!
	lembrar sempre qual a razão da existência das abstrações: esconder detalhes/gerenciar complexidade
	IMPORTANTE: os detalhes e sua complexidade AINDA ESTÃO LÁ e não devemos ignorá-los!

	faca de dois legumes: abstrair significa esconder detalhes adicionando contexto implicíto
	se quem vai usar api não estiver a par desse contexto implícito... coisas ruins podem acontecer :')
	ex: mike conversa naturalmente com lucas, dustin e will.
	mas às vezes tem dificuldade com a eleven às vezes tendo que explicar conceitos
	que outrora fossem básicos e esperados que todos o tivessem

	https://www.reddit.com/r/programming/comments/80agjz/handmade_hero_zero_50_cycles_cost_abstractions/

	apis e abstrações não existem no vácuo
	é necessário sempre considerar ambos os lados: implementação x uso
	é preciso contexto para tomar decisão informada quanto a onde melhor traçar a linha da abstração

	significa que ganhos que abstrações trazem são
	- diretamente proporcional à complexidade que ajudam a esconder
	- inversamente porporcional à sua superficie de uso (api)
	(deep vs shallow abstrations)

	lente: complexidade vs potencial x esforço de implementação
	- complexidade: complexidade com a qual estamos lidando
	- potencial: os ganhos que a api nos traz (facilidade, velocidade de iteração, segurança/assertividade, corretude, automatização)
	- esforço de implementação: literalmente o trabalho necessário para abstrair algo em uma api

	do que é feita uma boa api? (o section logo abaixo)

	agora é a parte prática? precisamos de exemplos! muitos deles!!!

	depois de citar uns exemplos:
	problema: lembra que abstração serve pra gerenciar complexidade?
	MUITO CUIDADO para acabar ADICIONANDO complexidade ao sistema

	complexidade?
	dois tipos de complexidade:
	- complexidade inerente: propriedades fundamentais do problema que estamos resolvendo
		- única maneira de reduzi-la é mudando o problema (o que é justo as vezes! design!)
	- complexidade acidental: complexidade adicionada por nossa própria solução!
		- essa queremos evitar ao máximo!
		- idealmente zero!!
		- geralmente causada por tentar adicionar uma solução que não pertence ao problema em questão!!

----

	iteração
	adições ou modificações devem ser feitas de tal modo que o produto final seja idealmente
	o mesmo caso o sistema inteiro fosse feito do zero com o conhecimento de dominio atual
	- não ter medo de refatoração ao inves de apenas tentar encaixar funcionalidade nova sem mexer muito no que já está lá

	o trabalho não é implementar o que o desginer ou producer pedem,
	mas sim *entender* o problema e então resolvê-lo
	- envolve fazer as perguntas certas
	
	reutilizar design é mais útil que reutilizar código!
	às vezes forçar reutilização de código apenas adicionar complexidade sem realmente adicionar valor a quem usa
	- exemplo da `resource collection` genéricas do jogo plataforma em rust que nunca chegou a existir
	- exemplo do `load asset` que recebia um caminho para carregamento e que também funcionava como chave de um cache
		- quebrou rapidamente pois assets de fonte também precisam do parametro do tamanho da fonte
		- isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
			- carregar e cachear assets
	- comparar com as coleções que existem no pepper
		- parecidas porém não 100%
		- facil de adicionar propriedades exclusivas e realmente aconteceu!

	** em algum momento citar https://ourmachinery.com/post/dig-shallow-graves/
	** em algum momento citar "A Philosophy of Software Design" https://www.youtube.com/watch?v=bmSAYlu0NcY
	** em algum momento citar "Why Black Boxes are so Hard to Reuse" https://www.youtube.com/watch?v=5l2wMgm7ZOk
	** em algum momento citar o guia de melhores praticas pra contribuintes da godot https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html

	comunicar soluções ao inves de features
	- focar apenas em features nos distancia do real problema que devemos solucionar
-->

<section>
	<h1>do que é feita uma boa api?</h1>
	<ul>
		<li>consciente quanto ao limite de suas abstrações
		<li>balanço entre simplicidade e profundidade
		<li>pre-condições, invariantes e pós-condições claras
		<li>implementação intuitiva
	</ul>
</section>

<section>
	<h1>late binding x early binding
</section>

<section>
	<h1>pre-condições, invariantes e pós-condições
</section>

<section>
	<h1>abstrações e vazamentos
	<h2>(meta-api vai aqui?)
</section>

<section>
	<h1>resto
	<h2>constness; debugabilidade; estrutura de dados; memória e propriedade; desempenho;
</section>

<!--
# API Design

## lente
complexidade x potencial x esforço de implementação

complexidade:
- dificuldade de entender
- má integração com o resto do código

potencial
- composabilidade
- funções e estruturas ortogonais
- mais casos de uso contemplados

esforço de implementação
- tempo do programador
- conceitos difíceis

----

## comunicação
Entender bem o caso de uso de quem realmente vai usar a API (outro programador, designer, etc).

## late binding x early binding
No início, queremos ter algo funcionando de forma simples.
No final, queremos ter controle total.

## código reutilizável e código fácil de deletar
A única forma de criar código reutilizável é por extraí-lo de código fácil de deletar.

## pre-condições, invariantes e pós-condições
Ser explícito e documentar!

ex:
- null
	- linguagens mais recentes têm esse conceito embutido (rust, zig, kotlin, C#8)
	- C# da unity não tem isso
	- BitStrap: `Option<T>`
- range de valores
- ordem de execução

## abstrações
Abstrações SEMPRE vazam. O desafio é escolher onde traçar a linha.

Modelagem de dados NÃO precisa seguir um modelo do mundo real.
Siga os dados! Mais importante é levar em consideração o tipo de acesso mais comum.

## simplicidade
Resolver o problema em questão e não mais.
Prototipação ajuda bastante a achar rápido o escopo. Escrever código para ser jogado fora (E JOGAR FORA MESMO).

Escrever mais código que o necessário, POR DEFINIÇÃO, apenas aumenta a complexidade da solução.

Diferentes problemas, requerem diferentes soluções.
Se o problema muda, a solução também muda!

Prototipação existe para entender o problema.
Comunicação!
Se você não entende o problema, a solução vai sofrer junto.

Future proofing não existe!

## constness
Const correctness.
Sempre preferir funções puras quando possível.
É um espectro, tentar sempre empurrar funções pro lado mais puro.

## debugabilidade
Considere debug em sua solução.
Onde estão seus dados? São fáceis de inspecionar?
É fácil acompanhar os caminhos de código por "stepping" no debbugger?

## estrutura de dados
Estruturas sequenciais (arrays) MUITO provavelmente são suficentes pra sua solução.
Processadores são MUITO bons em varrer memória linear.
Provavelmente não precisa de um hashmap ali.

## memória e propriedade
Quem é dono da memória (recurso)?
Ownership vs Borrowing.

Onde está ocorrendo alocação dinâmica no seu código?
É possível evitá-las? É possível evitar operações em strings? Minimizá-las?

C# => preferir structs; reusar coleções;
C++ => memória stack; temp allocator;

## desempenho
É um sistema grande? Pervasivo? Muitas entidades?
Onde há 1, há muitos! Qual o caso comum? É possível operar em quantidades?
É possível agrupar por tipos ao invés de coleções heterogêneas?
É possível multithread/job system?

## exemplos
https://mobile.twitter.com/rygorous/status/1507178315886444544

- dados estáticos em scriptable objects
	- já fazemos isso!
	- moral: separar dado que não muda/config em arquivos separados pra facilitar alteração, organização e controle

- classe Timer (Holodrive e depois BitStrap)
	- começo era classe com timer e duration e callback
	- depois struct e duration vinha de scriptable object
	- ai reparamo que também não precisava de callback
	- hoje eu colapsaria tudo em apenas uma função tipo o `SmoothDamp` da unity (recebe um `ref float timer` por parâmetro)
	- moral: não juntar dado com comportamento cedo demais

	- pergunta: `timer > 0.0f && timer -= delta_time_s` ou `timer < duration && timer += delta_time_s`?
		- `timer < duration` permite alterar o `duration` enquanto o timer tá rolando e continua funcionando como esperado!

- scene config demagnete
	- começou com tentar reaproveitar código genérico feito sem necessidade a ser resolvida
	- teve potencial suficiente pra ser possível implementar outros tipos de nós posteriormente
- sistema de dialogos neko
	- mudou por questão de usabilidade (alan usou de forma diferente)
	- mudou por entender melhor o problema (passar dialogo localmente x apenas o server passa)
- BitStrap
	- um bando de código reutilizável extraídos de um bando de código fácil de deletar
-->

