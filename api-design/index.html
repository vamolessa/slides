<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style.css">
<title>design de apis</title>
</head>
<body>

<section class="main">
    <h1>design de apis</h1>
    <h2>workshop bitcake 2022</h2>

    <footer>
        <p>por @ahvamolessa</p>
    </footer>
</section>

<section>
    <h1>objetivo</h1>
    <h2>refletir ativamente a respeito das decis√µes que tomamos ao arquitetar nossas solu√ß√µes</h2>

    <!--
    workshop um pouco filos√≥fico com o intuito de trazer pra frente pensamentos, que possivelmente
    estavam apenas no subconsciente, a respeito de design e abordagem de desenvolvimento de software.
    -->
</section>

<section style="background-image: url(thinker.jpg)">
    <h1><em>api</em> √© apresentar <em>abstra√ß√µes</em> atrav√©s de uma <em>interface</em></h1>

    <!--
    n√£o √© apenas sobre "application programming interface".
    mas sobre interfaces em geral e os lados de quem cria e de quem consome.
    -->
</section>

<section>
    <h1>por que interfaces?</h1>

    <!--
    por que interfaces s√£o importantes e por que falar a respeito?
    √© uma forma (comum) de abordar desenvolvimento de software onde
    n√≥s dividimos um problema complexo em camadas e/ou componentes.
    a forma como essa divis√£o acontece √© introduzindo interfaces.
    isso nos permite limitar o racioc√≠nio necess√°rio quanto √† resolu√ß√£o de problema
    ao inves de precisar manter um contexto enorme em mente mesmo ao realizar uma simples modifica√ß√£o.
    -->
</section>

<section style="background-image: url(imagination.jpg)">
    <h1>abstra√ß√µes</h1>

    <!--
    esse ato de encapsular complexidade a fim de simplificar seu uso √© abstrair.
    interfaces est√£o intrinsicamente relacionada a abstra√ß√µes.
    e abstra√ß√µes s√£o fundamentais ao gerenciamento de complexidade
    -->
</section>

<section style="background-image: url(complexity.jpg)">
    <h1>√© um modelo com o prop√≥sito de interpretar uma realidade rica em detalhes</h1>
    <h2>alcan√ßado por introduzir conceitos pertinentes ao dom√≠nio</h2>

    <!--
    nossa maior ferramenta para lidar com complexidade.
    a base inteira de computa√ß√£o √© feita por cima de camadas que abstraem detalhes cada vez mais baixo n√≠vel.
    
    uma abstra√ß√£o apenas pode ser criada por associar um conceito do dom√≠nio em quest√£o aos detalhes que desejamos esconder.
    muitas vezes criando conceitos novos no processo.
    -->
</section>

<section style="background-image: url(faca-dois-legumes.jpg)">
    <h1>abstrair = faca de dois legumes</h1>
    <h2>esconder complexidade <em>adiciona</em> complexidade</h2>

    <!--
    abstrair significa esconder detalhes adicionando presun√ß√µes impl√≠citas (contexto) que
    quem interagir com tal abstra√ß√£o deve estar a par.
    
    exemplo mais b√°sico desse processo √© dar nome a coisas. um nome carrega conceito e significado.
    por conta disso, uma abstra√ß√£o nova sempre vai pelo menos aumentar a carga cognitiva de um sistema.
    
    por√©m sua vantagem est√° em justamente criar uma nova forma (supostamente mais simples)
    de raciocinar a respeito de um problema ou sistema.
    √© um instrumento de comunica√ß√£o. uma ferramenta.
    -->
</section>

<section>
    <h1>abstrair != remover complexidade</h1>
    <h2>esconder significa que ainda est√° l√°</h2>

    <!--
    important√≠ssimo lembrar que os detalhes ainda est√£o l√°!
    abstrair n√£o significa que eles deixam de existir ou que podemos ignor√°-los completamente.
    -->
</section>

<section>
    <h1>problemas complexos s√£o complexos</h1>
    <p>a √∫nica maneira de simplificar um problema inerenentemente complexo √© resolvendo outro problema (que seja mais simples)</p>

    <!--
    resolver outro problema pode significar mudar o design (e tudo bem)!
    
    nosso trabalho n√£o √© implementar o que o desginer ou producer pedem,
    mas sim *entender* o problema e ent√£o resolv√™-lo
    fazer as perguntas certas!
    comunica√ß√£o! entender o problema!
    -->
</section>

<section>
    <h2>escrever mais c√≥digo que o necess√°rio <em>por defini√ß√£o</em> apenas aumenta a complexidade da solu√ß√£o</h2>

    <footer>
        <p><a href="http://number-none.com/blow/john_carmack_on_inlined_code.html">john carmack on inlined code</a></p>
    </footer>

    <!--
    tentar quebrar o problema em peda√ßos menores n√£o remove complexidade
    criar mais classes n√£o o torna mais simples
    criar mais fun√ß√µes n√£o o torna mais simples
    (inclusive pode apenas dificultar o entendimento da solu√ß√£o e, por consequ√™ncia, da api)
    -->
</section>

<section>
    <h1>complexidade inerente vs complexidade acidental</h1>
    <h2>inerente</h2>
    <ul>
    <li>propriedades fundamentais do problema</li>
    <li>√∫nica maneira de reduzi-la √© mudando o problema (e tudo bem!)</li>
    </ul>
    <h2>acidental</h2>
    <ul>
    <li>adicionada por n√≥s mesmos</li>
    <li>idealmente zero</li>
    <li>limita√ß√µes (linguagem, plataforma, design)</li>
    </ul>

    <!--
    todo problema possui uma complexidade inerente.
    qualquer complexidade extra √© acidental e deve ser ativamente minimizada.
    PRECISAMOS refletir honestamente se n√£o estamos inconscientemente adicionando complexidade acidental ao sistema!
    -->
</section>

<section>
    <h1>como saber qual complexidade estamos introduzindo?</h1>
    <ul>
    <li>entender o problema</li>
    <li>prototipa√ß√£o</li>
    <li>testar solu√ß√µes diferentes. refatorar</li>
    <li>evitar grandes solu√ß√µes gen√©ricas</li>
    <li>evitar future proofing ("fool's errand")</li>
    </ul>
    <p>erros e limita√ß√µes ser√£o encontrados independente da quantidade de design investido a priori. aceite-os e planeje-se!</p>

    <footer>
        <p><a href="https://ourmachinery.com/post/dig-shallow-graves/">dig shallow graves</a></p>
        <p><a href="https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html">best practices for godot engine contributors</a></p>
    </footer>

    <!--
    entender o problema √© fundamental.
    prototipa√ß√£o √© como se entende o problema!
    comunica√ß√£o! comunica√ß√£o com quem vai usar o sistema. quais s√£o suas reais necessidades?
    a √∫nica maneira de acertar um bom design de primeira √© com muita sorte ou ter experi√™ncia pr√©via resolvendo tal problema.
    √© sobre a jornada! prototipar, iterar e refatorar!
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>sistema de di√°logo neko</h1>
    <img src="dialog-before.png" />
    <p>come√ßou super flex√≠vel por√©m laborioso</p>

    <!--
    foi inclusive latente o problema de usabilidade
    uma vez que o alan tentou abstrair a flexibilidade do sistema
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>sistema de di√°logo neko</h1>
    <img src="dialog-after.png" />
    <p>reconhecendo o caso comum, otimizamos o processo</p>

    <!--
    entendendo melhor a forma como o sistema seria usado,
    foi poss√≠vel otimizar a usabilidade
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>sistema de di√°logo neko</h1>
    <img src="dialog-implementation.png" />
    <p>inclusive, a forma simples √© implementada por cima da flex√≠vel</p>

    <!--
    assim a gente ainda tem a op√ß√£o de ter controle total quando necess√°rio
    mantendo a facilidade de uso para o caso comum: posicionar camera + sequ√™ncia de di√°logo
    
    importante entender que ainda existe tradeoff que √© uma carga cognitiva maior
    por ter mais op√ß√µes e mais funcionalidades em geral
    -->
</section>

<section>
    <h1>c√≥digo reutiliz√°vel vs c√≥digo f√°cil de deletar</h1>
    <h2>a √∫nica forma de criar c√≥digo reutiliz√°vel √© extraindo-o de c√≥digo f√°cil de deletar</h2>

    <footer>
        <p><a href="https://caseymuratori.com/blog_0015">semantic compression</a></p>
        <p><a href="https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems">how to write disposable code in large systems</a></p>
    </footer>

    <!--
    c√≥digo f√°cil de deletar √© aquele que outros n√£o dependem
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>bitstrap (umake)</h1>
    <img src="umake.png" />
    <p>umake v2 vs v3</p>

    <!--
    bitstrap nada mais √© que um bando de c√≥digo reutiliz√°vel extra√≠dos de um bando de c√≥digo f√°cil de deletar
    
    (repara nas refer√™ncias fixas na v2)
    
    ex: scene config demagnete
    - come√ßou com tentar reaproveitar c√≥digo gen√©rico feito sem necessidade a ser resolvida
    - teve potencial suficiente pra ser poss√≠vel implementar outros tipos de n√≥s posteriormente
    -->
</section>

<section>
    <h1>apesar de tudo, abstra√ß√µes vazam</h1>
    <h2>sem exce√ß√£o</h2>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=5l2wMgm7ZOk">why black boxes are so hard to reuse</a></p>
    </footer>

    <!--
    acontece que abstra√ß√µes infelizmente t√™m essa propriedade de inevitavelmente vazar detalhes de sua implementa√ß√£o.
    n√£o importa o qu√£o boa √© uma abstra√ß√£o. ela vaza detalhes de alguma forma.
    
    ou seja: n√£o existe abstra√ß√£o perfeita. alguma coisa sempre se perde.
    e pode acontecer at√© de ter um ganho negativo: a abstra√ß√£o deixa o sistema em geral mais complexo do que seria sem ela.
    
    ex de abstracao:
    - carro manual => passar marcha √© um vazamento da implementa√ß√£o do carro (como funciona internamente)
    - carro automatico => n√£o √© 100% pois ainda existem `1`, `2`, `P`, al√©m do `D`
    - mesmo que fosse "100%", ainda existe manuten√ß√£o => precisa entender quando precisa levar ao mec√¢nico, checar agua, oleo, etc
    -->
</section>

<section>
    <h1>abstra√ß√µes apenas t√™m valor quando levantam seu pr√≥prio peso</h1>
    <h2>"programmers know the benefits of everything and the tradeoffs of nothing"</h2>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ">there are no zero-cost abstractions</a></p>
        <p><a href="https://www.youtube.com/watch?v=rI8tNMsozo0">simplicity matters</a></p>
    </footer>

    <!--
    importante pra nos lembrar dos custos de adicionar abstra√ß√µes a um sistema nos guia a onde tra√ßamos apis.
    
    lembrar que no inicio, queremos super agilidade, por√©m no final, queremos total controle.
    -->
</section>

<section>
    <h1>apis e abstra√ß√µes <em>n√£o</em> existem no v√°cuo</h1>
    <ul>
    <li>o que: abstra√ß√µes</li>
    <li>inten√ß√£o de uso: interface</li>
    <li>quem usa: comunica√ß√£o</li>
    <li>restri√ß√µes: linguagem, plataforma, in√©rcia dos c√≥digos j√° existentes</li>
    </ul>

    <footer>
        <p><a href="https://cellperformance.beyond3d.com/articles/2006/04/performance-and-good-data-design.html">performance and good data design</a></p>
        <p><a href="https://quuxplusone.github.io/blog/2022/06/23/unordered-multiset-equal-range/">c++: unordered_multiset's api affects its big-o</a></p>
    </footer>

    <!--
    - o que: custos de abstra√ß√£o
    - inten√ß√£o de uso: uso da api √© t√£o importante quanto sua implementa√ß√£o
    - quem usa: entender o problema. as reais necessidades de quem vai usar a api
    - restri√ß√µes: o que a gente tem pra trabalhar. alvos de desempenho, etc. c√≥digos j√° escritos que ir√£o interagir com o sistema novo
    
    tomar decis√£o informada quanto a onde tra√ßamos a linha da abstra√ß√£o
    -->
</section>

<section class="main">
    <h1>uma api √© boa se ela √© <em>profunda</em> e possui <em>interface enxuta</em></h1>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=bmSAYlu0NcY">a philosophy of software design</a></p>
    </footer>

    <!--
    enfim do que √© feita uma boa api!
    criar abstra√ß√µes que adicionam valor substancial ao sistema, √† solu√ß√£o e aos usu√°rios.
    -->
</section>

<section style="background-image: url(granularity.jpg)">
    <h1>granularidade</h1>
    <p>abstra√ß√µes acontecem em v√°rios n√≠veis, mas o potencial √© proporcional √† escala</p>

    <!--
    n√≠veis: nome, fun√ß√£o, classe, m√≥dulo, programa, sistema, etc.
    temos mais potencial de profundidade quanto maior a escala.
    
    realidade: classes s√£o granulares demais para promoverem sozinhas uma api profunda.
    
    isso nos induz a manter interfaces permissivas e flutuantes entre classes de um mesmo m√≥dulo/sistema.
    e deixar pra implementar interfaces formais e impenetr√°veis de api a n√≠vel de m√≥dulos no m√≠nimo.
    
    na pr√°tica: encapsulamento (getter/setter, vari√°veis e fun√ß√µes privadas/protegidas, arquivos super fragmentados, etc)
    n√£o s√£o importantes enquanto estamos no mesmo m√≥dulo.
    √© tudo parte de uma mesma implementa√ß√£o: a abstra√ß√£o principal do sistema.
    -->
</section>

<section>
    <h1>profunda</h1>
    <ul>
    <li>ortogonal</li>
    <li>compos√≠vel</li>
    <li>complexidade adicionada < complexidade abstra√≠da</li>
    <h1>interface enxuta</h1>
    </ul>
    <ul>
    <li>padr√µes razo√°veis</li>
    <li>estado m√≠nimo</li>
    <li>invariantes expl√≠citas</li>
    <li>intui sua implementa√ß√£o</li>
    </ul>
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>ortogonal</h1>
    <img src="orthogonal.png" />
    <p>conceitos s√£o independentes e n√£o se influenciam</p>

    <!--
    conceitos s√£o ortogonais at√© n√£o serem mais
    -->
</section>

<section>
    <p>ortogonal</p>
    <h1>altura do pulo ‚ùå</h1>
    <img src="jump-config.png" />
    <img src="gravity-config.png" />
    <img src="stick-config.png" />

    <!--
    tanto mudar impulso de pulo quanto gravidade influenciam altura do pulo
    mais ainda: quando o gato t√° grudado a um prop, o peso do prop e os multiplicadores tamb√©m influenciam
    -->
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>compos√≠vel</h1>
    <p>qu√£o f√°cil √© a intera√ß√£o com outras abstra√ß√µes?</p>
    <p>(mais pr√°tico quando h√° um canal uniforme que integra sistemas)</p>

    <!--
    um pouco menos pr√°tico para os nossos casos j√° que costumamos fazer sistemas especializados.
    algo a se levar em conta ao analizar c√≥digos de terceiros.
    -->
</section>

<section>
    <p>compos√≠vel</p>
    <h1>narrow waist</h1>
    <p>exemplo: unix pipeline</p>
    <pre><code>ls -l | grep key | less</code></pre>

    <footer>
        <p><a href="https://www.oilshell.org/blog/2022/03/backlog-arch.html">a sketch of the biggest idea in software architecture</a></p>
    </footer>

    <!--
    faca de dois legumes: facilita a comunica√ß√£o entre sistemas, limita a comunica√ß√£o entre sistemas
    -->
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <p>compos√≠vel</p>
    <h1>late binding x early binding</h1>
    <p>no in√≠cio, queremos simplicidade</p>
    <p>no final, queremos controle total</p>

    <!--
    "binding" √© um conceito que vem de programa√ß√£o funcional. basicamente significa dar um nome a um valor (to bind).
    "late binding" era uma das propostas de alan kay em sua vis√£o para orienta√ß√£o a objetos realizada em smalltalk.
    a linguagem deixa pra decidir no √∫ltimo momento qual o valor que um nome tem.
    temos reflexo disso em fun√ß√µes virtuais + overloading em que o c√≥digo que ser√° executado s√≥ √© sabido na hora da chamada.
    
    n√£o √© bom nem ruim por si s√≥. depende do contexto.
    
    late binding d√° flexibilidade por√©m dificulta valida√ß√£o. e vice-versa para early binding.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>late binding dialogo neko</h1>
    <pre><code>class UNekoDialogueCharacterDataAsset : public UDataAsset {
    ENekoDialogueCharacterId Id = ENekoDialogueCharacterId::None;

    TArray&ltTSoftObjectPtr&ltUTexture2D&gt&gt Expressions;

    // implementado com for
    UTexture2D* GetExpression(ENekoDialogueCharacterExpression Expression);
};</code></pre>

    <!--
    todas as express√µes ficam no array expressions.
    teoricamente temos flexibilidade pra configurar as express√µes,
    mas na pr√°tica, todos os personagems v√£o ter as mesmas entradas.
    f√°cil esquecer ou duplicar uma express√£o por n√£o ter valida√ß√£o.
    
    `GetExpression` √© um `for` que busca uma entrada em `Expressions` que seja do tipo `Expression`. opera√ß√£o fal√≠vel.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>early binding dialogo neko</h1>
    <pre><code>class UNekoDialogueCharacterDataAsset : public UDataAsset {
    ENekoDialogueCharacterId Id = ENekoDialogueCharacterId::None;

    TSoftObjectPtr&ltUTexture2D&gt ExpressionDefault;
    TSoftObjectPtr&ltUTexture2D&gt ExpressionAngry;
    TSoftObjectPtr&ltUTexture2D&gt ExpressionHappy;

    // implementado com switch
    UTexture2D* GetExpression(ENekoDialogueCharacterExpression Expression);
};</code></pre>

    <!--
    agora listamos todas as express√µes explicitamente.
    imposs√≠vel duplicar. esquecer uma express√£o significa ter um buraco vazio no editor.
    
    `GetExpression` agora √© um `switch` que √© implementado na m√£o. por√©m agora √© uma opera√ß√£o infal√≠vel.
    -->
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>complexidade adicionada < complexidade abstra√≠da</h1>
    <p>abstra√ß√µes devem puxar mais que seu pr√≥prio peso</p>
    <p>entender os tradeoffs feitos</p>
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <p>complexidade adicionada < complexidade abstra√≠da</p>
    <h1>desempenho</h1>
    <ul>
    <li>√© um sistema pervasivo? muitas entidades?</li>
    <li>onde h√° um, h√° muitos! qual o caso comum? operar em lotes!</li>
    <li>agrupar por tipos ao inv√©s de cole√ß√µes heterog√™neas</li>
    <li>particionar ao inv√©s de branch</li>
    <li>multithread? job system?</li>
    </ul>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>padr√µes razo√°veis</h1>

    <!--
    criar um "pit of success" pra quem for usar
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>padr√µes razo√°veis</p>
    <h1>"data driven"</h1>
    <p>extrair dados est√°ticos em arquivos separados</p>
    <ul>
    <li>unity: scriptable objects</li>
    <li>unreal: data asset</li>
    </ul>

    <!--
    separar dado que n√£o muda/config em arquivos separados pra facilitar altera√ß√£o, organiza√ß√£o e controle
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>padr√µes razo√°veis</p>
    <h1>estruturas de dados</h1>
    <p>arrays <em>muito</em> provavelmente s√£o suficientes</p>
    <p>processadores adoram mem√≥ria linear</p>
    <p>*olha feio praquela lista encadeada* üò†</p>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>estado m√≠nimo</h1>
    <p>sobre quais os dados a api opera?</p>
    <p>onde eles s√£o alterados?</p>

    <footer>
        <p><a href="https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-">in detph: functional programming in c++</a></p>
        <p><a href="https://mobile.twitter.com/rygorous/status/1507178315886444544">twitter - sobre estado</a></p>
    </footer>

    <!--
    n√£o √© sobre anarquia! :B
    facilitar entendimento e reflex√£o por diminuir "partes m√≥veis".
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>estado m√≠nimo</p>
    <h1>const correctness</h1>
    <p>preferir estilo funcional sempre que poss√≠vel</p>
    <p>facilita compreens√£o. menos dependente de ordem de execu√ß√£o</p>
    <pre><code>// evitar
obj.CheckSomething();
obj.MaybeDoSomethingInResponse();

// preferir
var result = obj.CheckSomething();
if (result) {
    obj.DoSomethingInResponse(result);
}</code></pre>

    <footer>
        <p><a href="https://isocpp.org/wiki/faq/const-correctness">c++ const correctness</a></p>
    </footer>

    <!--
    as linhas serem breves s√£o um falso indicador da complexidade por tr√°s uma vez que
    para realmente entender o que est√° acontecendo, agora devemos ter em mente o estado interno de `obj`.
    mudar a ordem das linhas ou esquecer uma delas facilmente causar√° bugs.
    
    aqui `CheckSomething` n√£o modifica o estado interno de obj e apenas retorna o resultado calculado.
    enquanto `DoSomethingInResponse` explicitamente age em cima do resultado obtido.
    tamb√©m est√° expl√≠cito o `if` que antes estava escondido em `MaybeDoSomethingInResponse`.
    
    ex: maquina de estados opengl.
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>estado m√≠nimo</p>
    <h1>recursos e posse</h1>
    <p>quem √© o respons√°vel pelo recurso?</p>
    <p>posse vs empr√©stimo</p>
    <p>onde h√° aloca√ß√£o de mem√≥ria? poss√≠vel evit√°-la?</p>
    <ul>
    <li>c# = preferir structs e arrays; reusar cole√ß√µes</li>
    <li>c++ = arrays; inline allocator;</li>
    </ul>

    <footer>
        <p><a href="https://docs.microsoft.com/en-us/dotnet/standard/memory-and-spans/memory-t-usage-guidelines#owners-consumers-and-lifetime-management">c# memory and spans - owners, consumers and lifetime management</a></p>
        <p><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L25">List.cs</a></p>
        <p><a href="https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Containers/TInlineAllocator/">TInlineAllocator</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>invariantes expl√≠citas</h1>
    <p>+ pr√©-condi√ß√µes</p>
    <p>+ p√≥s-condi√ß√µes</p>

    <!--
    uma propriedade do sistema que √© sempre verdade.
    ex: esse ponteiro sempre aponta para mem√≥ria v√°lida.
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>invariantes expl√≠citas</p>
    <h1>null</h1>
    <p>pr√©-condi√ß√£o: quais fun√ß√µes podem <em>receber</em> null?</p>
    <p>p√≥s-condi√ß√£o: quais fun√ß√µes podem <em>retornar</em> null?</p>
    <p>decidir e ser expl√≠cito!</p>
    <p>linguagens mais recentes t√™m esse conceito embutido (rust, zig, kotlin, c#8)</p>
    <ul>
    <li>c# da unity n√£o tem isso</li>
    <li>bitstrap: <code>Option<T></code></li>
    </ul>

    <footer>
        <p><a href="https://github.com/bitcake/bitstrap/blob/master/Assets/Runtime/Functional/Option.cs">Option.cs</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>invariantes expl√≠citas</p>
    <h1>minimizar erros</h1>
    <p>dois tipos de erros:</p>
    <ul>
    <li>entrada/sa√≠da => tratar</li>
    <li>l√≥gica => assert</li>
    </ul>

    <footer>
        <p>"define errors out of existence" -- ousterhout, john</p>
        <p><a href="https://nullprogram.com/blog/2022/06/26/">assertions should be more debugger-oriented</a></p>
    </footer>

    <!--
    qualquer outro tipo de erro √© desnecess√°rio
    
    TODO: expandir exemplo
    ex: pepper CommandTokenizer
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h2>intervalo de valores</h2>
    <p>usar tipos para codificar valores v√°lidos</p>
    <pre><code>// evitar
int GetPlayerCount();

// preferir
uint8 GetPlayerCount();</code></pre>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>intui sua implementa√ß√£o</h1>
    <p>a partir de uma transforma√ß√£o conhecida, √© poss√≠vel inferir aproximadamente suas entradas e sa√≠das</p>

    <!--
    quando nos dispomos a implementar um sistema, intuitivamente devemos ter no√ß√£o da forma de suas entradas e sa√≠das.
    da mesma forma quando vamos consumir uma api que se prop√µe a resolver um determinado problema,
    temos uma no√ß√£o do que esperar de sua interface.
    
    ex: api para baixar arquivo (url)
    ex: api para desenhar ret√¢ngulo (x, y, w, h, color)
    
    em cada um dos exemplos, d√° pra se aprofundar em mais detalhes:
    http vs ftp vs tcp/ip; rota√ß√£o, tamanho borda, gradiente vs textura; etc.
    
    por√©m o importante √© que ainda assim, o formato das entradas e sa√≠das ainda se assemelham ao intuido.
    se, por outro lado, a interface diverge demais do esperado, √© prov√°vel que n√£o seja uma boa api.
    -->
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <p>intui sua implementa√ß√£o</p>
    <h1>debugabilidade</h1>
    <ul>
    <li>onde est√£o os dados?</li>
    <li>s√£o f√°ceis de inspecionar?</li>
    <li>√© f√°cil acompanhar o que est√° acontecendo pelo debugger?</li>
    </ul>
</section>

<section style="background-image: url(galaxy-brain.png)">
    <h1>√†s vezes n√£o precisa de api ou abstra√ß√£o</h1>
    <h2>c√≥digo vai, design fica</h2>

    <!--
    nosso trabalho √© resolver problema. escrever c√≥digo √© consequ√™ncia.
    
    reutilizar design √© mais √∫til que reutilizar c√≥digo!
    √†s vezes for√ßar reutiliza√ß√£o de c√≥digo apenas adicionar complexidade sem realmente adicionar valor a quem usa
    
    TODO: expandir exemplo?
    - exemplo da `resource collection` gen√©ricas do jogo plataforma em rust que nunca chegou a existir
    - exemplo do `load asset` que recebia um caminho para carregamento e que tamb√©m funcionava como chave de um cache
        - quebrou rapidamente pois assets de fonte tamb√©m precisam do parametro do tamanho da fonte
        - isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
            - carregar e cachear assets
    - comparar com as cole√ß√µes que existem no pepper
        - parecidas por√©m n√£o 100%
        - facil de adicionar propriedades exclusivas e realmente aconteceu!
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe AssetLoader</h1>
    <pre><code>pub trait Asset: Sync + Send + 'static {
    type Id: fmt::Debug + Hash + Eq + Clone + Sync + Send;
}
pub trait AssetLoader&lt'a, A: Asset&gt {
    type Storage;
    fn load(&'a self, id: &A::Id, storage: &mut Self::Storage) -&gt Result&ltA, AssetLoadError&gt;
}
pub fn try_load&lt'a, S&gt(
    &mut self,
    id: &A::Id,
    loader: &'a AssetLoader&lt'a, A, Storage = S&gt,
    storage: &mut S,
) -&gt Result&ltAssetHandle&ltA&gt, AssetLoadError&gt {
    match self.cache_map.get(id).cloned() {
        Some(handle) =&gt Ok(handle),
        None =&gt {
            let asset = loader.load(id, storage)?;
            let handle = self.add(asset);
            self.cache_map.insert(id.clone(), handle);
            Ok(handle)
        }
    }
}</code></pre>

    <!--
    come√ßou como uma abstra√ß√£o template pra carregar assets de v√°rios tipos a partir de um path.
    at√© que chegamos em fontes, que precisam de um path + font-size. quebrou a abstra√ß√£o precoce!
    acontece que eu continuei no caminho da abstra√ß√£o criando mais camadas adicionando mais templates
    se distanciando cada vez mais da solu√ß√£o do problema: carregar assets do disco.
    
    enquanto isso, a solu√ß√£o basicamente *pedia* que fosse separada em v√°rias structs ao inves de uma gen√©rica.
    anos depois quando fui programar meu editor de c√≥digo, n√£o cai na mesma armadilha e separei as cole√ß√µes de
    Buffers, BufferViews, Plugins e Clients (todas t√™m um Handle associado).
    Dessa forma, √© super f√°cil de adicionar funcionalidade pr√≥pria de cada cole√ß√£o sem influenciar ou estar amarrado
    √†s outras cole√ß√µes.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe timer v1</h1>
    <pre><code>public class Timer { // holodrive
    [SerializeField] private float length = 1.0f; // serializado
    private float counter = 0.0f;
    public System.Action OnTimer { get; set; } // callback

    public void OnUpdate() {
        if( counter &lt 0.0f ) {
            // Already triggered callback.
        } else if( counter &lt length ) {
            counter += Time.deltaTime;
        } else {
            counter = -1.0f;
            if( OnTimer != null )
                OnTimer();
        }
    }
}</code></pre>

    <!--
    v√°rios detalhes omitidos
    cl√°ssica implementa√ß√£o orientada a objetos
    
    `length` √© serializado no MonoBehaviour
    callbacks s√£o configurados no Start/Awake
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe timer v2</h1>
    <pre><code>public sealed class Timer { // demagnete
    public float length = 1.0f; // dinamico
    private float elapsedTime = -1.0f;

    public bool OnUpdate() { // sem callback
        if( elapsedTime &gt= 0.0f )
            elapsedTime += Time.deltaTime;
        if( elapsedTime &lt length ) {
            elapsedTime = -1.0f;
            return true;
        }
        return false;
    }
}</code></pre>

    <!--
    quase sempre o que a gente queria, na verdade, era configurar a dura√ß√£o do timer em um ScriptableObject.
    igualmente, os callbacks costumavam ser bem curtos. suas declara√ß√µes eram ru√≠do.
    
    antes de iniciar o timer, muda o valor de `length` com base num ScriptableObject.
    api "immediate mode" aproveitando que `OnUpdate` j√° precisava ser chamado todo frame.
    c√≥digo do callback inline dentro de um `if`. bem mais f√°cil de acompanhar os caminhos de c√≥digo.
    -->
</section>

<section>
    <p>exemplo</p>
    <h1>classe timer v3</h1>
    <pre><code>float Timer = -1.0f; // neko
// ...
void AMyActor::Tick(float DeltaSeconds) {
    if (Timer &gt= 0.0f) {
        Timer += DeltaSeconds;
        if (Timer &gt= Config-&gtTimerDuration) {
            // do the thing!
            Timer = -1.0f;
        }
    }
}</code></pre>

    <!--
    em sua √∫ltima itera√ß√£o, n√£o existe mais classe timer.
    agora √© apenas um idioma. um padr√£o que emerge nos c√≥digos.
    adicionar uma classe apenas aumentaria a complexidade com ganhos √≠nfimos.
    n√£o h√° mais a necessidade de abstrair.
    
    para come√ßar o timer, √© s√≥ fazer `Timer = 0.0f`.
    
    bonus: reparar que √© poss√≠vel aumentar o `TimerDuration` enquanto o timer est√° rodando e continua funcionando.
    -->
</section>

<section class="main">
    <h1>3 big lies</h1>
    <ul>
    <li>software is a platform</li>
    <li>code should be designed around a model of the world</li>
    <li>code is more important than data</li>
    </ul>

    <footer>
        <p><a href="https://cellperformance.beyond3d.com/articles/2008/03/three-big-lies.html">three big lies</a></p>
    </footer>

    <!--
    software is a platform
    - hardware √© a platforma
    - pra nos lembrar das implica√ß√µes de desempenho que nossas abstra√ß√µes implicam
    
    code should be designed around a model of the world
    - dados e suas transforma√ß√µes devem guiar o design
    - pre-mapear rela√ß√µes e conceitos de mundo em uma solu√ß√£o apenas adiciona ruido e restri√ß√µes desnecess√°rias
        - e, portanto, dificulta chegar ao melhor design
    
    code is more important than data
    - dados s√£o mais importantes
    - c√≥digo n√£o existe pra ser bonito. a solu√ß√£o n√£o existe pra ser bonita. ambos existem pra resolver o problema
    - as apis devem refletir isso. elas *precisam* resolver o problema e nada mais.
        - caso contrario apenas adicionam complexidade acidental ao sistema
    -->
</section>

<section>
    <h1>design de api = ponderar custo-benef√≠cios</h1>
    <p>"everything should be made as simple as possible, but not simpler."</p>
    <p>-- einstein, albert (supostamente)</p>

    <footer>
        <p>valeu! falou! :)</p>
    </footer>

    <!--
    "tudo deve ser feito o mais simples poss√≠vel, por√©m n√£o mais simples que isso."
    
    uma solu√ß√£o que poderia ser mais simples possui desperd√≠cio.
    uma solu√ß√£o que √© simples demais ignora detalhes importantes.
    
    √© atrav√©s de simplicidade que atingimos apis balanceadas entre custo e benef√≠cio
    -->
</section>

</body>
</html>
