<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style.css">
<title>design de apis</title>

<main>
	<h1>design de apis
	<h2>workshop bitcake 2022
</main>

<section style="background-image: url(thinker.jpg)">
	<h1><em>api</em> é apresentar uma ou mais <em>abstrações</em> através de uma <em>interface</em>
</section>
<!--
intrinsicamente relacionada a abstrações
fundamental ao gerenciamento de complexidade
-->

<section style="background-image: url(imagination.jpg)">
	<h1>abstrações
	<h2>ato de esconder complexidade
</section>
<!--
razoável
porém importantíssimo lembrar que a complexidade ainda está lá (mais sobre isso depois)
-->

<section style="background-image: url(complexity.jpg)">
	<h1>é um modelo com o propósito de interpretar uma realidade rica em detalhes
	<h2>e isso é feito introduzindo conceitos pertinentes ao domínio
</section>
<!--
nossa maior ferramenta para lidar com complexidade
a base inteira de computação é feita por cima de camadas que abstraem detalhes cada vez mais baixo nível

uma abstração apenas pode ser criada por associar um conceito do domínio do problema em questão
aos detalhes que desejamos esconder. isso muitas vezes criando conceitos novos no processo.

exemplo mais básico desse processo é dar nome a coisas.
por conta disso, uma abstração nova sempre vai pelo menos aumentar a carga cognitiva de um sistema
-->

<section>
	<h1>toda novo conceito adicionado ao sistema, o torna mais complexo
</section>
<!--
porém sua vantagem está em justamente criar uma nova forma (supostamente mais simples) de raciocinar a respeito de um problema
é um instrumento de comunicação no final das contas
-->

<section>
	<h1>complexidade inerente vs complexidade acidental</h1>

	<ul>
		<li>limitações da linguagem
		<li>limitações da plataforma
		<li>limitações de nosso próprio design (pior de todos)
	</ul>
</section>
<!--
todo problema possui uma complexidade inerente
toda complexidade adicional em sua solução é puramente acidental
PRECISA refletir honestamente se não estamos inconscientemente adicionando complexidade acidental ao sistema!
-->

<section>
	<h1>como saber qual complexidade estamos introduzindo?</h1>

	<ul>
		<li>entender o problema
		<li>iteração de implementação <em>e</em> design
		<li>testar soluções diferentes. refatorar
		<li>evitar future proofing ("fool's errand")
		<li>erros e limitações serão encontrados independente da quantidade de design investido a priori. aceite-os
	</ul>

	<footer>
		<a href="https://ourmachinery.com/post/dig-shallow-graves/">dig shallow graves</a>
	</footer>
</section>
<!--
entender o problema
comunicação!
resolver os problemas certos

iteração
adições ou modificações devem ser feitas de tal modo que o produto final seja idealmente
o mesmo caso o sistema inteiro fosse feito do zero com o conhecimento de dominio atual
- não ter medo de refatoração ao inves de apenas tentar encaixar funcionalidade nova sem mexer muito no que já está lá
-->

<section>
	<h1>problemas complexos são complexos</h1>
	<p>a única maneira de simplificar um problema inerenentemente complexo é resolvendo outro problema (que seja mais simples)
</section>
<!--
tentar quebrá-lo em pedaços menores não o torna mais simples
criar mais classes não o torna mais simples
criar mais funções não o torna mais simples
(inclusive pode apenas dificultar o entendimento da solução e, por consequência, da api)

escrever mais código que o necessário, POR DEFINIÇÃO, apenas aumenta a complexidade da solução.

resolver outro problema pode significar mudar o design!

o trabalho não é implementar o que o desginer ou producer pedem,
mas sim *entender* o problema e então resolvê-lo
fazer as perguntas certas!
comunicação! entender o problema!
-->

<section>
	<h2>"everything should be made as simple as possible, but not simpler."</h2>
	<p>- Einstein, Albert
	<footer>supostamente</footer>
</section>

<section style="background-image: url(flextape.jpg)">
	<h1>porém abstrações vazam</h1>
	<h2>sem exceção</h2>
	<footer>
		<a href="https://www.youtube.com/watch?v=5l2wMgm7ZOk">why black boxes are so hard to reuse</a>
	</footer>
</section>
<!--
acontece que abstrações infelizmente têm essa propriedade de inevitavelmente vazar detalhes de sua implementação

ou seja: não existe abstração perfeita. alguma coisa sempre se perde.
e pode acontecer até de ter um ganho negativo: a abstração deixa o sistema em geral mais complexo do que seria sem ela.

TODO: exemplo do carro? (marchas, etc)
também adicionam complexidade!
precisam levantar seu próprio peso!
-->

<main>
	<h1>uma api é boa se ela é <em>profunda</em> e possui <em>interface enxuta</em>
</main>
<!--
esse é o âmago da ideia
criar abstrações que adicionam valor ao software em questão porém que contribuem minimamente ao aumento de sua complexidade
-->

<section>
	<h1>profunda</h1>
	<ul>
		<li>ortogonal
		<li>composível
		<li>complexidade adicionada < complexidade abstraída
		<li>vazamento mínimo
	</ul>

	<h1>interface enxuta</h1>
	<ul>
		<li>padrões razoáveis
		<li>estado mínimo e explícito
		<li>pré-condições + invariantes + pós-condições
		<li>intui sua implementação
	</ul>
</section>
<!--
TODO: expandir agora ou depois?

ortogonal = conceitos são independentes e não se influenciam
composível = é permitido e talvez até fácil de interagir com outras abstrações
adicionada < abstraída = puxar mais que seu próprio peso
vazamento mínimo

padrões razoáveis = criar um "pit of success" pra quem for usar
estado mínimo = é implementação porém vaza facilmente. ex: ordem de execução
condições + invariantes = explicidade. também gerenciamento de erros
	Const correctness.
	Sempre preferir funções puras quando possível.
	É um espectro, tentar sempre empurrar funções pro lado mais puro.

	ex:
	- null
		- linguagens mais recentes têm esse conceito embutido (rust, zig, kotlin, C#8)
		- C# da unity não tem isso
		- BitStrap: `Option<T>`
	- range de valores
	- ordem de execução
intui implementação = faz parte da interface saber (pelo menos) superficialmente sobre sua implementação!
-->


<section style="background-image: url(design.jpg)">
	<h1>às vezes não precisa de api ou abstração
	<h2>código vai mas o design fica
</section>
<!--
nosso trabalho é resolver problema. escrever código é consequência.

reutilizar design é mais útil que reutilizar código!
às vezes forçar reutilização de código apenas adicionar complexidade sem realmente adicionar valor a quem usa
- exemplo da `resource collection` genéricas do jogo plataforma em rust que nunca chegou a existir
- exemplo do `load asset` que recebia um caminho para carregamento e que também funcionava como chave de um cache
	- quebrou rapidamente pois assets de fonte também precisam do parametro do tamanho da fonte
	- isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
		- carregar e cachear assets
- comparar com as coleções que existem no pepper
	- parecidas porém não 100%
	- facil de adicionar propriedades exclusivas e realmente aconteceu!

-->

<main>
	<h1>3 big lies</h1>

	<ul>
		<li>software is a platform
		<li>code should be designed around a model of the world
		<li>code is more important than data
	</ul>

	<footer>
		<a href="https://cellperformance.beyond3d.com/articles/2008/03/three-big-lies.html">three big lies</a>
	</footer>
</main>
<!--
- software is a platform
	- hardware é a platforma
	- pra nos lembrar das implicações de desempenho que nossas abstrações implicam
- code should be designed around a model of the world
	- dados e suas transformações devem guiar o design
	- pre-mapear relações e conceitos de mundo em uma solução apenas adiciona ruido e restrições desnecessárias
		- e, portanto, dificulta chegar ao melhor design
- code is more important than data
	- dados são mais importantes
	- código não existe pra ser bonito. a solução não existe pra ser bonita. ambos existem pra resolver o problema
	- as apis devem refletir isso. elas *precisam* resolver o problema e nada mais.
		- caso contrario apenas adicionam complexidade acidental ao sistema
-->

<main>
	<h1>extras práticos
</main>

<section>
	<h1>late binding x early binding

	<p>no início, queremos simplicidade
	<p>no final, queremos controle total
</section>

<section>
	<h1>debugabilidade

	<p>onde estão os dados?
	<p>são fáceis de inspecionar?
	<p>é fácil acompanhar o que está acontecendo pelo debugger?
</section>

<section>
	<h1>estruturas de dados

	<p>arrays <em>muito</em> provavelmente são suficientes
	<p>processadores adoram memória linear
	<p>*olha feio praquela lista encadeada*
</section>

<section>
	<h1>recursos e posse

	<p>quem é o responsável pelo recurso?
	<p>posse vs emprestimo
	<p>onde há alocação de memória? da pra evitá-la?

	<p>C# = preferir structs e arrays; reusar coleções
	<p>C++ = arrays; inline allocator;

	<footer>
		<a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L25">List.cs</a>
		<a href="https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Containers/TInlineAllocator/">TInlineAllocator</a>
	</footer>
</section>

<section>
	<h1>desempenho

	<p>é um sistema pervasivo? muitas entidades?
	<p>onde há um, há muitos! qual o caso comum? operar em lotes!
	<p>agrupar por tipos ao invés de coleções heterogêneas
	<p>particionar ao invés de branch
	<p>multithread? job system?
</section>






<!--
# iteração

## código reutilizável e código fácil de deletar
A única forma de criar código reutilizável é por extraí-lo de código fácil de deletar.

Diferentes problemas, requerem diferentes soluções.
Se o problema muda, a solução também muda!

Prototipação existe para entender o problema.
Comunicar com quem irá usar o sistema.

Se você não entende o problema, menos chances de implementar uma boa solução

-->

<!--
	TODAS abstrações vazam!!
	escolher onde tracar a linha da abstração
	ex de abstracao:
	- carro manual => passar marcha é um vazamento da implementação do carro (como funciona internamente)
	- carro automatico => não é 100% pois ainda existem `1`, `2`, `P`, além do `D`
	- mesmo que fosse "100%", ainda existe manutenção => precisa entender quando precisa levar ao mecânico, checar agua, oleo, etc
	- toda abstração vaza detalhes de implementação!
		- e tudo bem! isso não invalida suas utilidades
		- porem, existe um gradiente aí! mesmo sempre existindo vazamento, é de nosso interesse minimizá-lo!!
		- https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ&index=11

	importante: escolher onde traça a linha de abstração
		- escolher o que é abstraido e o que é exposto
		- ser consciente quanto a isso!
	lembrar sempre qual a razão da existência das abstrações: esconder detalhes/gerenciar complexidade
	IMPORTANTE: os detalhes e sua complexidade AINDA ESTÃO LÁ e não devemos ignorá-los!

	faca de dois legumes: abstrair significa esconder detalhes adicionando contexto implicíto
	se quem vai usar api não estiver a par desse contexto implícito... coisas ruins podem acontecer :')
	ex: mike conversa naturalmente com lucas, dustin e will.
	mas às vezes tem dificuldade com a eleven às vezes tendo que explicar conceitos
	que outrora fossem básicos e esperados que todos o tivessem

	https://www.reddit.com/r/programming/comments/80agjz/handmade_hero_zero_50_cycles_cost_abstractions/

	apis e abstrações não existem no vácuo
	é necessário sempre considerar ambos os lados: implementação x uso
	é preciso contexto para tomar decisão informada quanto a onde melhor traçar a linha da abstração

	agora é a parte prática? precisamos de exemplos! muitos deles!!!

	depois de citar uns exemplos:
	problema: lembra que abstração serve pra gerenciar complexidade?
	MUITO CUIDADO para acabar ADICIONANDO complexidade ao sistema

	complexidade?
	dois tipos de complexidade:
	- complexidade inerente: propriedades fundamentais do problema que estamos resolvendo
		- única maneira de reduzi-la é mudando o problema (o que é justo as vezes! design!)
	- complexidade acidental: complexidade adicionada por nossa própria solução!
		- essa queremos evitar ao máximo!
		- idealmente zero!!
		- geralmente causada por tentar adicionar uma solução que não pertence ao problema em questão!!

----
	** em algum momento citar "A Philosophy of Software Design" https://www.youtube.com/watch?v=bmSAYlu0NcY
	** em algum momento citar "Why Black Boxes are so Hard to Reuse" https://www.youtube.com/watch?v=5l2wMgm7ZOk
	** em algum momento citar o guia de melhores praticas pra contribuintes da godot https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html
	** citar "simplicity matters" https://www.youtube.com/watch?v=rI8tNMsozo0

	comunicar soluções ao inves de features
	- focar apenas em features nos distancia do real problema que devemos solucionar
-->

<!--
## exemplos
https://mobile.twitter.com/rygorous/status/1507178315886444544

- dados estáticos em scriptable objects
	- já fazemos isso!
	- moral: separar dado que não muda/config em arquivos separados pra facilitar alteração, organização e controle

- classe Timer (Holodrive e depois BitStrap)
	- começo era classe com timer e duration e callback
	- depois struct e duration vinha de scriptable object
	- ai reparamo que também não precisava de callback
	- hoje eu colapsaria tudo em apenas uma função tipo o `SmoothDamp` da unity (recebe um `ref float timer` por parâmetro)
	- moral: não juntar dado com comportamento cedo demais

	- pergunta: `timer > 0.0f && timer -= delta_time_s` ou `timer < duration && timer += delta_time_s`?
		- `timer < duration` permite alterar o `duration` enquanto o timer tá rolando e continua funcionando como esperado!

- scene config demagnete
	- começou com tentar reaproveitar código genérico feito sem necessidade a ser resolvida
	- teve potencial suficiente pra ser possível implementar outros tipos de nós posteriormente
- sistema de dialogos neko
	- mudou por questão de usabilidade (alan usou de forma diferente)
	- mudou por entender melhor o problema (passar dialogo localmente x apenas o server passa)
- BitStrap
	- um bando de código reutilizável extraídos de um bando de código fácil de deletar

-->

