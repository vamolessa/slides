<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style.css">
<title>design de apis</title>
</head>
<body>

<section class="main">
    <h1>design de apis</h1>
    <h2>workshop bitcake 2022</h2>

    <footer>
        <p>por @ahvamolessa</p>
    </footer>
</section>

<section style="background-image: url(thinker.jpg)">
    <h1><em>api</em> é apresentar <em>abstrações</em> através de uma <em>interface</em></h1>
</section>

<section>
    <h1>por que interfaces?</h1>
</section>

<section style="background-image: url(imagination.jpg)">
    <h1>abstrações</h1>
</section>

<section style="background-image: url(complexity.jpg)">
    <h1>é um modelo com o propósito de interpretar uma realidade rica em detalhes</h1>
    <h2>alcançado por introduzir conceitos pertinentes ao domínio</h2>
</section>

<section style="background-image: url(faca-dois-legumes.jpg)">
    <h1>abstrair = faca de dois legumes</h1>
    <h2>esconder complexidade <em>adiciona</em> complexidade</h2>
</section>

<section>
    <h1>abstrair != remover complexidade</h1>
    <h2>esconder significa que ainda está lá</h2>
</section>

<section>
    <h1>problemas complexos são complexos</h1>
    <p>a única maneira de simplificar um problema inerenentemente complexo é resolvendo outro problema (que seja mais simples)</p>
</section>

<section>
    <h2>escrever mais código que o necessário <em>por definição</em> apenas aumenta a complexidade da solução</h2>

    <footer>
        <p><a href="http://number-none.com/blow/john_carmack_on_inlined_code.html">john carmack on inlined code</a></p>
    </footer>
</section>

<section>
    <h1>complexidade inerente vs complexidade acidental</h1>
    <h2>inerente</h2>
    <ul>
    <li>propriedades fundamentais do problema</li>
    <li>única maneira de reduzi-la é mudando o problema (e tudo bem!)</li>
    </ul>
    <h2>acidental</h2>
    <ul>
    <li>adicionada por nós mesmos</li>
    <li>idealmente zero</li>
    <li>limitações (linguagem, plataforma, design)</li>
    </ul>
</section>

<section>
    <h1>como saber qual complexidade estamos introduzindo?</h1>
    <ul>
    <li>entender o problema</li>
    <li>prototipação</li>
    <li>testar soluções diferentes. refatorar</li>
    <li>evitar grandes soluções genéricas</li>
    <li>evitar future proofing ("fool's errand")</li>
    </ul>
    <p>erros e limitações serão encontrados independente da quantidade de design investido a priori. aceite-os e planeje-se!</p>

    <footer>
        <p><a href="https://ourmachinery.com/post/dig-shallow-graves/">dig shallow graves</a></p>
        <p><a href="https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html">best practices for godot engine contributors</a></p>
    </footer>
</section>

<section>
    <h1>código reutilizável vs código fácil de deletar</h1>
    <h2>a única forma de criar código reutilizável é extraindo-o de código fácil de deletar</h2>

    <footer>
        <p><a href="https://caseymuratori.com/blog_0015">semantic compression</a></p>
        <p><a href="https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems">how to write disposable code in large systems</a></p>
    </footer>
</section>

<section>
    <h1>apesar de tudo, abstrações vazam</h1>
    <h2>sem exceção</h2>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=5l2wMgm7ZOk">why black boxes are so hard to reuse</a></p>
    </footer>
</section>

<section>
    <h1>abstrações apenas têm valor quando levantam seu próprio peso</h1>
    <h2>"programmers know the benefits of everything and the tradeoffs of nothing"</h2>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ">there are no zero-cost abstractions</a></p>
        <p><a href="https://www.youtube.com/watch?v=rI8tNMsozo0">simplicity matters</a></p>
    </footer>
</section>

<section>
    <h1>apis e abstrações <em>não</em> existem no vácuo</h1>
    <ul>
    <li>o que: abstrações</li>
    <li>intenção de uso: interface</li>
    <li>quem usa: comunicação</li>
    <li>restrições: linguagem, plataforma, inércia dos códigos já existentes</li>
    </ul>

    <footer>
        <p><a href="https://cellperformance.beyond3d.com/articles/2006/04/performance-and-good-data-design.html">performance and good data design</a></p>
        <p><a href="https://quuxplusone.github.io/blog/2022/06/23/unordered-multiset-equal-range/">c++: unordered_multiset's api affects its big-o</a></p>
    </footer>
</section>

<section class="main">
    <h1>uma api é boa se ela é <em>profunda</em> e possui <em>interface enxuta</em></h1>

    <footer>
        <p><a href="https://www.youtube.com/watch?v=bmSAYlu0NcY">a philosophy of software design</a></p>
    </footer>
</section>

<section style="background-image: url(granularity.jpg)">
    <h1>granularidade</h1>
    <p>abstrações acontecem em vários níveis, mas o potencial é proporcional à escala</p>
</section>

<section>
    <h1>profunda</h1>
    <ul>
    <li>ortogonal</li>
    <li>composível</li>
    <li>complexidade adicionada < complexidade abstraída</li>
    <h1>interface enxuta</h1>
    </ul>
    <ul>
    <li>padrões razoáveis</li>
    <li>estado mínimo e explícito</li>
    <li>pré-condições + invariantes + pós-condições</li>
    <li>intui sua implementação</li>
    </ul>
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>ortogonal</h1>
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>composível</h1>
</section>

<section>
    <header>
        <p>profunda</p>
    </header>

    <h1>complexidade adicionada < complexidade abstraída</h1>
</section>

<section>
    <header>
        <p>profunda / complexidade adicionada < complexidade abstraída</p>
    </header>

    <h2>desempenho</h2>
    <ul>
    <li>é um sistema pervasivo? muitas entidades?</li>
    <li>onde há um, há muitos! qual o caso comum? operar em lotes!</li>
    <li>agrupar por tipos ao invés de coleções heterogêneas</li>
    <li>particionar ao invés de branch</li>
    <li>multithread? job system?</li>
    </ul>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>padrões razoáveis</h1>
</section>

<section>
    <header>
        <p>interface enxuta / padrões razoáveis</p>
    </header>

    <h2>estruturas de dados</h2>
    <p>arrays <em>muito</em> provavelmente são suficientes</p>
    <p>processadores adoram memória linear</p>
    <p>*olha feio praquela lista encadeada*</p>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>estado mínimo e explícito</h1>
    <p>sobre quais os dados a api opera?</p>
    <p>onde eles são alterados?</p>

    <footer>
        <p><a href="https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-">in detph: functional programming in c++</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta / estado mínimo e explícito</p>
    </header>

    <h2>const correctness</h2>
    <p>preferir estilo funcional sempre que possível</p>
    <p>facilita compreensão. menos dependente de ordem de execução</p>
    <pre><code>// evitar
obj.CheckSomething();
obj.MaybeDoSomethingInResponse();

// preferir
var result = obj.CheckSomething();
if (result) {
    obj.DoSomethingInResponse(result);
}</code></pre>

    <footer>
        <p><a href="https://isocpp.org/wiki/faq/const-correctness">c++ const correctness</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta / estado mínimo e explícito</p>
    </header>

    <h2>recursos e posse</h2>
    <p>quem é o responsável pelo recurso?</p>
    <p>posse vs empréstimo</p>
    <p>onde há alocação de memória? possível evitá-la?</p>
    <ul>
    <li>c# = preferir structs e arrays; reusar coleções</li>
    <li>c++ = arrays; inline allocator;</li>
    </ul>

    <footer>
        <p><a href="https://docs.microsoft.com/en-us/dotnet/standard/memory-and-spans/memory-t-usage-guidelines#owners-consumers-and-lifetime-management">c# memory and spans - owners, consumers and lifetime management</a></p>
        <p><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L25">List.cs</a></p>
        <p><a href="https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Containers/TInlineAllocator/">TInlineAllocator</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>pré-condições + invariantes + pós-condições</h1>
</section>

<section>
    <header>
        <p>interface enxuta / pré-condições + invariantes + pós-condições</p>
    </header>

    <h2>null</h2>
    <p>pré-condição: quais funções podem <em>receber</em> null?</p>
    <p>pós-condição: quais funções podem <em>retornar</em> null?</p>
    <p>decidir e ser explícito!</p>
    <p>linguagens mais recentes têm esse conceito embutido (rust, zig, kotlin, c#8)</p>
    <ul>
    <li>c# da unity não tem isso</li>
    <li>bitstrap: <code>Option<T></code></li>
    </ul>

    <footer>
        <p><a href="https://github.com/bitcake/bitstrap/blob/master/Assets/Runtime/Functional/Option.cs">Option.cs</a></p>
    </footer>
</section>

<section>
    <header>
        <p>interface enxuta / pré-condições + invariantes + pós-condições</p>
    </header>

    <h2>minimizar erros</h2>
    <p>dois tipos de erros:</p>
    <ul>
    <li>entrada/saída => tratar</li>
    <li>lógica => assert</li>
    </ul>
    <p>"define errors out of existence"</p>
    <p>-- ousterhout, john</p>
</section>

<section>
    <h2>intervalo de valores</h2>
    <p>usar tipos para codificar valores válidos</p>
    <pre><code>// evitar
int GetPlayerCount();

// preferir
uint8 GetPlayerCount();</code></pre>
</section>

<section>
    <header>
        <p>interface enxuta</p>
    </header>

    <h1>intui sua implementação</h1>
    <p>a partir de uma transformação conhecida, é possível inferir aproximadamente suas entradas e saídas</p>
</section>

<section>
    <header>
        <p>interface enxuta / intui sua implementação</p>
    </header>

    <h2>debugabilidade</h2>
    <ul>
    <li>onde estão os dados?</li>
    <li>são fáceis de inspecionar?</li>
    <li>é fácil acompanhar o que está acontecendo pelo debugger?</li>
    </ul>
</section>

<section style="background-image: url(galaxy-brain.png)">
    <h1>às vezes não precisa de api ou abstração</h1>
    <h2>código vai, design fica</h2>
</section>

<section class="main">
    <h1>3 big lies</h1>
    <ul>
    <li>software is a platform</li>
    <li>code should be designed around a model of the world</li>
    <li>code is more important than data</li>
    </ul>

    <footer>
        <p><a href="https://cellperformance.beyond3d.com/articles/2008/03/three-big-lies.html">three big lies</a></p>
    </footer>
</section>

<section>
    <h1>late binding x early binding</h1>
    <p>no início, queremos simplicidade</p>
    <p>no final, queremos controle total</p>
</section>

<section>
    <h1>design de api = ponderar custo-benefícios</h1>
    <p>"everything should be made as simple as possible, but not simpler."</p>
    <p>-- einstein, albert (supostamente)</p>

    <footer>
        <p>valeu! falou! :)</p>
    </footer>
</section>

</body>
</html>
