# design de apis
## workshop bitcake 2022
background:main
footer:por @ahvamolessa
---

# *api* é apresentar *abstrações* através de uma *interface*
background:thinker.jpg
---

# ======================
===
TODO:
estabelece os 4 topicos e depois os destrincha separadamente:

o que influencia api:
- o que: abstracoes
- intenção de uso: interface
- quem usa: comunicação
- restricoes: linguagem, plataforma, resto do software, etc
---

# abstrações
background:imagination.jpg
===
intrinsicamente relacionada a abstrações
fundamental ao gerenciamento de complexidade
---

# é um modelo com o propósito de interpretar uma realidade rica em detalhes
## alcançado por introduzir conceitos pertinentes ao domínio
background:complexity.jpg
===
nossa maior ferramenta para lidar com complexidade
a base inteira de computação é feita por cima de camadas que abstraem detalhes cada vez mais baixo nível

uma abstração apenas pode ser criada por associar um conceito do domínio do problema em questão
aos detalhes que desejamos esconder. isso muitas vezes criando conceitos novos no processo.

faca de dois legumes: abstrair significa esconder detalhes adicionando contexto implicíto
se quem vai usar api não estiver a par desse contexto implícito... coisas ruins podem acontecer :')
ex: mike conversa naturalmente com lucas, dustin e will.
mas às vezes tem dificuldade com a eleven às vezes tendo que explicar conceitos
que outrora fossem básicos e esperados que todos o tivessem

importantíssimo lembrar que os detalhes ainda estão lá! eles NÃO somem

exemplo mais básico desse processo é dar nome a coisas.
por conta disso, uma abstração nova sempre vai pelo menos aumentar a carga cognitiva de um sistema
---

# todo novo conceito adicionado ao sistema o torna mais complexo
===
porém sua vantagem está em justamente criar uma nova forma (supostamente mais simples) de raciocinar a respeito de um problema
é um instrumento de comunicação no final das contas
---

# complexidade inerente vs complexidade acidental
- limitações da linguagem
- limitações da plataforma
- ou pior: limitações de nosso próprio design
===
todo problema possui uma complexidade inerente
toda complexidade adicional em sua solução é puramente acidental
PRECISA refletir honestamente se não estamos inconscientemente adicionando complexidade acidental ao sistema!

- inerente: propriedades fundamentais do problema que estamos resolvendo
	- única maneira de reduzi-la é mudando o problema (o que é justo as vezes! design!)
- acidental: adicionada por nossa própria solução!
	- essa queremos evitar ao máximo!
	- idealmente zero!!
	- geralmente causada por tentar adicionar uma solução que não pertence ao problema em questão!!
---

# como saber qual complexidade estamos introduzindo?
- entender o problema
- prototipação
- testar soluções diferentes. refatorar
- evitar future proofing ("fool's errand")
- erros e limitações serão encontrados independente da quantidade de design investido a priori. aceite-os e planeje-se

footer:[dig shallow graves](https://ourmachinery.com/post/dig-shallow-graves/)
===
TODO: é sobre a jornada (iteração até chegar no design final)

entender o problema
prototipação é como se entende o problema!
comunicação! comunicação com quem deve usar o sistema
a única maneira de acertar um bom design de primeira é com muita sorte ou ter experiência prévia resolvendo tal problema
---

# código reutilizável vs código fácil de deletar
## a única forma de criar código reutilizável é extraindo-o de código fácil de deletar

footer:[semantic compression](https://caseymuratori.com/blog_0015)
footer:[how to write disposable code in large systems](https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems)
---

# problemas complexos são complexos
a única maneira de simplificar um problema inerenentemente complexo é resolvendo outro problema (que seja mais simples)

footer:[john carmack on inlined code](http://number-none.com/blow/john_carmack_on_inlined_code.html)
===
tentar quebrá-lo em pedaços menores não o torna mais simples
criar mais classes não o torna mais simples
criar mais funções não o torna mais simples
(inclusive pode apenas dificultar o entendimento da solução e, por consequência, da api)

escrever mais código que o necessário, POR DEFINIÇÃO, apenas aumenta a complexidade da solução.

resolver outro problema pode significar mudar o design!

o trabalho não é implementar o que o desginer ou producer pedem,
mas sim *entender* o problema e então resolvê-lo
fazer as perguntas certas!
comunicação! entender o problema!
---

# abstrações vazam
## sem exceção
footer:[why black boxes are so hard to reuse](https://www.youtube.com/watch?v=5l2wMgm7ZOk)
===
acontece que abstrações infelizmente têm essa propriedade de inevitavelmente vazar detalhes de sua implementação

ou seja: não existe abstração perfeita. alguma coisa sempre se perde.
e pode acontecer até de ter um ganho negativo: a abstração deixa o sistema em geral mais complexo do que seria sem ela.

ex de abstracao:
- carro manual => passar marcha é um vazamento da implementação do carro (como funciona internamente)
- carro automatico => não é 100% pois ainda existem `1`, `2`, `P`, além do `D`
- mesmo que fosse "100%", ainda existe manutenção => precisa entender quando precisa levar ao mecânico, checar agua, oleo, etc
- toda abstração vaza detalhes de implementação!
	- e tudo bem! isso não invalida suas utilidades
	- porem, existe um gradiente aí! mesmo sempre existindo vazamento, é de nosso interesse minimizá-lo!!
	- https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ&index=11
---

# abstrações apenas têm valor quando levantam seu próprio peso
## "programmers know the benefits of everything and the tradeoffs of nothing"

footer:[simplicity matters](https://www.youtube.com/watch?v=rI8tNMsozo0)
===
importante pra nos lembrar dos custos de adicionar abstrações a um sistema
nos guia a onde traçamos apis
---

# "everything should be made as simple as possible, but not simpler."
-- einstein, albert (supostamente)
---

# apis e abstrações *não* existem no vácuo
intenção de uso influencia design
restrições influenciam design

footer:[performance and good data design](https://cellperformance.beyond3d.com/articles/2006/04/performance-and-good-data-design.html)
footer:[best practices for godot engine contributors](https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html)
===
TODO: atualmente redundante com "o que influencia api" lá em cima

é necessário sempre considerar ambos os lados: implementação x uso
é preciso contexto para tomar decisão informada quanto a onde melhor traçar a linha da abstração
---

# uma api é boa se ela é *profunda* e possui *interface enxuta*
background:main
footer:[a philosophy of software design](https://www.youtube.com/watch?v=bmSAYlu0NcY)
===
esse é o âmago da ideia
criar abstrações que adicionam valor ao software em questão porém que contribuem minimamente ao aumento de sua complexidade
---

# ======================
===
TODO:

abstrações acontecem em varios niveis, mas api precisa ser profunda.

granularidade:
apenas modulos têm granularidade suficiente para serem profundos
classes já são muito granulares

pra refletir:
por que acreditamos no que acreditamos?

por que abordamos software da maneira que fazemos?
onde aprendemos isso?

apenas classes, uma classe por arquivo
segundo periodo faculdade!
ide java fazem isso

modulos sao uma unidade de anstraçao onde apis sao definidas
nao ganhamos nada espalhando seu codigo
---

# profunda
- ortogonal
- composível
- complexidade adicionada < complexidade abstraída
- vazamento mínimo

# interface enxuta
- padrões razoáveis
- estado mínimo e explícito
- pré-condições + invariantes + pós-condições
- intui sua implementação
===
TODO: expandir slides

ortogonal = conceitos são independentes e não se influenciam
composível = é permitido e talvez até fácil de interagir com outras abstrações
adicionada < abstraída = puxar mais que seu próprio peso
vazamento mínimo

padrões razoáveis = criar um "pit of success" pra quem for usar
estado mínimo = é implementação porém vaza facilmente. ex: ordem de execução
condições + invariantes = explicidade. também gerenciamento de erros
	Const correctness.
	Sempre preferir funções puras quando possível.
	É um espectro, tentar sempre empurrar funções pro lado mais puro.

	ex:
	- null
		- linguagens mais recentes têm esse conceito embutido (rust, zig, kotlin, C#8)
		- C# da unity não tem isso
		- BitStrap: `Option<T>`
	- range de valores
	- ordem de execução
intui implementação = faz parte da interface saber (pelo menos) superficialmente sobre sua implementação!

TODO: https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-
---

# às vezes não precisa de api ou abstração
## código vai mas o design fica

background:design.jpg
===
nosso trabalho é resolver problema. escrever código é consequência.

reutilizar design é mais útil que reutilizar código!
às vezes forçar reutilização de código apenas adicionar complexidade sem realmente adicionar valor a quem usa
- exemplo da `resource collection` genéricas do jogo plataforma em rust que nunca chegou a existir
- exemplo do `load asset` que recebia um caminho para carregamento e que também funcionava como chave de um cache
	- quebrou rapidamente pois assets de fonte também precisam do parametro do tamanho da fonte
	- isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
		- carregar e cachear assets
- comparar com as coleções que existem no pepper
	- parecidas porém não 100%
	- facil de adicionar propriedades exclusivas e realmente aconteceu!
---

# 3 big lies
- software is a platform
- code should be designed around a model of the world
- code is more important than data

background:main
footer:[three big lies](https://cellperformance.beyond3d.com/articles/2008/03/three-big-lies.html)
===
- software is a platform
	- hardware é a platforma
	- pra nos lembrar das implicações de desempenho que nossas abstrações implicam
- code should be designed around a model of the world
	- dados e suas transformações devem guiar o design
	- pre-mapear relações e conceitos de mundo em uma solução apenas adiciona ruido e restrições desnecessárias
		- e, portanto, dificulta chegar ao melhor design
- code is more important than data
	- dados são mais importantes
	- código não existe pra ser bonito. a solução não existe pra ser bonita. ambos existem pra resolver o problema
	- as apis devem refletir isso. elas *precisam* resolver o problema e nada mais.
		- caso contrario apenas adicionam complexidade acidental ao sistema
---

# extras práticos
background:main
---

# late binding x early binding
no início, queremos simplicidade
no final, queremos controle total
---

# debugabilidade
onde estão os dados?
são fáceis de inspecionar?
é fácil acompanhar o que está acontecendo pelo debugger?
---

# estruturas de dados
arrays *muito* provavelmente são suficientes
processadores adoram memória linear
\*olha feio praquela lista encadeada\*
---

# recursos e posse
quem é o responsável pelo recurso?
posse vs emprestimo
onde há alocação de memória? da pra evitá-la?

C# = preferir structs e arrays; reusar coleções
C++ = arrays; inline allocator;

footer:[List.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L25)
footer:[TInlineAllocator](https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Containers/TInlineAllocator/)
---

# desempenho
é um sistema pervasivo? muitas entidades?
onde há um, há muitos! qual o caso comum? operar em lotes!
agrupar por tipos ao invés de coleções heterogêneas
particionar ao invés de branch
multithread? job system?

===
## exemplos
https://mobile.twitter.com/rygorous/status/1507178315886444544

- dados estáticos em scriptable objects
	- já fazemos isso!
	- moral: separar dado que não muda/config em arquivos separados pra facilitar alteração, organização e controle

- classe Timer (Holodrive e depois BitStrap)
	- começo era classe com timer e duration e callback
	- depois struct e duration vinha de scriptable object
	- ai reparamo que também não precisava de callback
	- hoje eu colapsaria tudo em apenas uma função tipo o `SmoothDamp` da unity (recebe um `ref float timer` por parâmetro)
	- moral: não juntar dado com comportamento cedo demais

	- pergunta: `timer > 0.0f && timer -= delta_time_s` ou `timer < duration && timer += delta_time_s`?
		- `timer < duration` permite alterar o `duration` enquanto o timer tá rolando e continua funcionando como esperado!

- scene config demagnete
	- começou com tentar reaproveitar código genérico feito sem necessidade a ser resolvida
	- teve potencial suficiente pra ser possível implementar outros tipos de nós posteriormente
- sistema de dialogos neko
	- mudou por questão de usabilidade (alan usou de forma diferente)
	- mudou por entender melhor o problema (passar dialogo localmente x apenas o server passa)
- BitStrap
	- um bando de código reutilizável extraídos de um bando de código fácil de deletar

