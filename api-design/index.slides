# design de apis
## workshop bitcake 2022
lang:pt-BR
background:main
footer:por @ahvamolessa
---

# objetivo
## refletir ativamente a respeito das decis√µes que tomamos ao arquitetar nossas solu√ß√µes
===
workshop um pouco filos√≥fico com o intuito de trazer pra frente pensamentos, que possivelmente
estavam apenas no subconsciente, a respeito de design e abordagem de desenvolvimento de software.
---

# *api* √© apresentar *abstra√ß√µes* atrav√©s de uma *interface*
background:thinker.jpg
===
n√£o √© apenas sobre "application programming interface".
mas sobre interfaces em geral e os lados de quem cria e de quem consome.
---

# por que interfaces?
===
por que interfaces s√£o importantes e por que falar a respeito?
√© uma forma (comum) de abordar desenvolvimento de software onde
n√≥s dividimos um problema complexo em camadas e/ou componentes.
a forma como essa divis√£o acontece √© introduzindo interfaces.
isso nos permite limitar o racioc√≠nio necess√°rio quanto √† resolu√ß√£o de problema
ao inves de precisar manter um contexto enorme em mente mesmo ao realizar uma simples modifica√ß√£o.
---

# abstra√ß√µes
background:imagination.jpg
===
esse ato de encapsular complexidade a fim de simplificar seu uso √© abstrair.
interfaces est√£o intrinsicamente relacionada a abstra√ß√µes.
e abstra√ß√µes s√£o fundamentais ao gerenciamento de complexidade
---

# √© um modelo com o prop√≥sito de interpretar uma realidade rica em detalhes
## alcan√ßado por introduzir conceitos pertinentes ao dom√≠nio
background:complexity.jpg
===
nossa maior ferramenta para lidar com complexidade.
a base inteira de computa√ß√£o √© feita por cima de camadas que abstraem detalhes cada vez mais baixo n√≠vel.

uma abstra√ß√£o apenas pode ser criada por associar um conceito do dom√≠nio em quest√£o aos detalhes que desejamos esconder.
muitas vezes criando conceitos novos no processo.
---

# abstrair = faca de dois legumes
## esconder complexidade *adiciona* complexidade
background:faca-dois-legumes.jpg
===
abstrair significa esconder detalhes adicionando presun√ß√µes impl√≠citas (contexto) que
quem interagir com tal abstra√ß√£o deve estar a par.

exemplo mais b√°sico desse processo √© dar nome a coisas. um nome carrega conceito e significado.
por conta disso, uma abstra√ß√£o nova sempre vai pelo menos aumentar a carga cognitiva de um sistema.

por√©m sua vantagem est√° em justamente criar uma nova forma (supostamente mais simples)
de raciocinar a respeito de um problema ou sistema.
√© um instrumento de comunica√ß√£o. uma ferramenta.
---

# abstrair != remover complexidade
## esconder significa que ainda est√° l√°
===
important√≠ssimo lembrar que os detalhes ainda est√£o l√°!
abstrair n√£o significa que eles deixam de existir ou que podemos ignor√°-los completamente.
---

# problemas complexos s√£o complexos
a √∫nica maneira de simplificar um problema inerenentemente complexo √© resolvendo outro problema (que seja mais simples)
===
resolver outro problema pode significar mudar o design (e tudo bem)!

nosso trabalho n√£o √© implementar o que o desginer ou producer pedem,
mas sim *entender* o problema e ent√£o resolv√™-lo
fazer as perguntas certas!
comunica√ß√£o! entender o problema!
---

## escrever mais c√≥digo que o necess√°rio *por defini√ß√£o* apenas aumenta a complexidade da solu√ß√£o
footer:[john carmack on inlined code](http://number-none.com/blow/john_carmack_on_inlined_code.html)
===
tentar quebrar o problema em peda√ßos menores n√£o remove complexidade
criar mais classes n√£o o torna mais simples
criar mais fun√ß√µes n√£o o torna mais simples
(inclusive pode apenas dificultar o entendimento da solu√ß√£o e, por consequ√™ncia, da api)
---

# complexidade inerente vs complexidade acidental
## inerente
- propriedades fundamentais do problema
- √∫nica maneira de reduzi-la √© mudando o problema (e tudo bem!)

## acidental
- adicionada por n√≥s mesmos
- idealmente zero
- limita√ß√µes (linguagem, plataforma, design)

footer:[complexity](https://www.ncameron.org/blog/complexity/)
===
todo problema possui uma complexidade inerente.
qualquer complexidade extra √© acidental e deve ser ativamente minimizada.
PRECISAMOS refletir honestamente se n√£o estamos inconscientemente adicionando complexidade acidental ao sistema!
---

# como saber qual complexidade estamos introduzindo?
- entender o problema
- prototipa√ß√£o
- testar solu√ß√µes diferentes. refatorar
- evitar grandes solu√ß√µes gen√©ricas
- evitar future proofing ("fool's errand")

erros e limita√ß√µes ser√£o encontrados independente da quantidade de design investido a priori. aceite-os e planeje-se!

footer:[dig shallow graves](https://ourmachinery.com/post/dig-shallow-graves/)
footer:[best practices for godot engine contributors](https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html)
===
entender o problema √© fundamental.
prototipa√ß√£o √© como se entende o problema!
comunica√ß√£o! comunica√ß√£o com quem vai usar o sistema. quais s√£o suas reais necessidades?
a √∫nica maneira de acertar um bom design de primeira √© com muita sorte ou ter experi√™ncia pr√©via resolvendo tal problema.
√© sobre a jornada! prototipar, iterar e refatorar!
---

exemplo
# sistema de di√°logo neko
!dialog-before.png
come√ßou super flex√≠vel por√©m laborioso
===
foi inclusive latente o problema de usabilidade
uma vez que o alan tentou abstrair a flexibilidade do sistema
---

exemplo
# sistema de di√°logo neko
!dialog-after.png
reconhecendo o caso comum, otimizamos o processo
===
entendendo melhor a forma como o sistema seria usado,
foi poss√≠vel otimizar a usabilidade
---

exemplo
# sistema de di√°logo neko
!dialog-implementation.png
inclusive, a forma simples √© implementada por cima da flex√≠vel
===
assim a gente ainda tem a op√ß√£o de ter controle total quando necess√°rio
mantendo a facilidade de uso para o caso comum: posicionar camera + sequ√™ncia de di√°logo

importante entender que ainda existe tradeoff que √© uma carga cognitiva maior
por ter mais op√ß√µes e mais funcionalidades em geral
---

# c√≥digo reutiliz√°vel vs c√≥digo f√°cil de deletar
## a √∫nica forma de criar c√≥digo reutiliz√°vel √© extraindo-o de c√≥digo f√°cil de deletar
footer:[semantic compression](https://caseymuratori.com/blog_0015)
footer:[how to write disposable code in large systems](https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems)
===
c√≥digo f√°cil de deletar √© aquele que outros n√£o dependem
---

exemplo
# bitstrap (umake)
!umake.png
umake v2 vs v3
===
bitstrap nada mais √© que um bando de c√≥digo reutiliz√°vel extra√≠dos de um bando de c√≥digo f√°cil de deletar

(repara nas refer√™ncias fixas na v2)

ex: scene config demagnete
- come√ßou com tentar reaproveitar c√≥digo gen√©rico feito sem necessidade a ser resolvida
- teve potencial suficiente pra ser poss√≠vel implementar outros tipos de n√≥s posteriormente
---

# apesar de tudo, abstra√ß√µes vazam
## sem exce√ß√£o
footer:[why black boxes are so hard to reuse](https://www.youtube.com/watch?v=5l2wMgm7ZOk)
===
acontece que abstra√ß√µes infelizmente t√™m essa propriedade de inevitavelmente vazar detalhes de sua implementa√ß√£o.
n√£o importa o qu√£o boa √© uma abstra√ß√£o. ela vaza detalhes de alguma forma.

ou seja: n√£o existe abstra√ß√£o perfeita. alguma coisa sempre se perde.
e pode acontecer at√© de ter um ganho negativo: a abstra√ß√£o deixa o sistema em geral mais complexo do que seria sem ela.

ex de abstracao:
- carro manual => passar marcha √© um vazamento da implementa√ß√£o do carro (como funciona internamente)
- carro automatico => n√£o √© 100% pois ainda existem `1`, `2`, `P`, al√©m do `D`
- mesmo que fosse "100%", ainda existe manuten√ß√£o => precisa entender quando precisa levar ao mec√¢nico, checar agua, oleo, etc
---

# abstra√ß√µes apenas t√™m valor quando levantam seu pr√≥prio peso
## "programmers know the benefits of everything and the tradeoffs of nothing"
footer:[there are no zero-cost abstractions](https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ)
footer:[simplicity matters](https://www.youtube.com/watch?v=rI8tNMsozo0)
===
importante pra nos lembrar dos custos de adicionar abstra√ß√µes a um sistema nos guia a onde tra√ßamos apis.

lembrar que no inicio, queremos super agilidade, por√©m no final, queremos total controle.
---

# apis e abstra√ß√µes *n√£o* existem no v√°cuo
- o que: abstra√ß√µes
- inten√ß√£o de uso: interface
- quem usa: comunica√ß√£o
- restri√ß√µes: linguagem, plataforma, in√©rcia dos c√≥digos j√° existentes
footer:[performance and good data design](https://cellperformance.beyond3d.com/articles/2006/04/performance-and-good-data-design.html)
footer:[c++: unordered_multiset's api affects its big-o](https://quuxplusone.github.io/blog/2022/06/23/unordered-multiset-equal-range/)
===
- o que: custos de abstra√ß√£o
- inten√ß√£o de uso: uso da api √© t√£o importante quanto sua implementa√ß√£o
- quem usa: entender o problema. as reais necessidades de quem vai usar a api
- restri√ß√µes: o que a gente tem pra trabalhar. alvos de desempenho, etc. c√≥digos j√° escritos que ir√£o interagir com o sistema novo

tomar decis√£o informada quanto a onde tra√ßamos a linha da abstra√ß√£o
---

# uma api √© boa se ela √© *profunda* e possui *interface enxuta*
background:main
footer:[a philosophy of software design](https://www.youtube.com/watch?v=bmSAYlu0NcY)
===
enfim do que √© feita uma boa api!
criar abstra√ß√µes que adicionam valor substancial ao sistema, √† solu√ß√£o e aos usu√°rios.
---

# granularidade
## abstra√ß√µes acontecem em v√°rios n√≠veis, mas o potencial √© proporcional √† escala
background:granularity.jpg
===
n√≠veis: nome, fun√ß√£o, classe, m√≥dulo, programa, sistema, etc.
temos mais potencial de profundidade quanto maior a escala.

realidade: classes s√£o granulares demais para promoverem sozinhas uma api profunda.

isso nos induz a manter interfaces permissivas e flutuantes entre classes de um mesmo m√≥dulo/sistema.
e deixar pra implementar interfaces formais e impenetr√°veis de api a n√≠vel de m√≥dulos no m√≠nimo.

na pr√°tica: encapsulamento (getter/setter, vari√°veis e fun√ß√µes privadas/protegidas, arquivos super fragmentados, etc)
n√£o s√£o importantes enquanto estamos no mesmo m√≥dulo.
√© tudo parte de uma mesma implementa√ß√£o: a abstra√ß√£o principal do sistema.
---

# profunda
- ortogonal
- compos√≠vel
- complexidade adicionada < complexidade abstra√≠da
# interface enxuta
- padr√µes razo√°veis
- estado m√≠nimo
- invariantes expl√≠citas
- intui sua implementa√ß√£o
background:main
---

# ortogonal
!orthogonal.png
conceitos s√£o independentes e n√£o se influenciam
header:profunda
===
conceitos s√£o ortogonais at√© n√£o serem mais
---

ortogonal
# altura do pulo ‚ùå
!jump-config.png
!gravity-config.png
!stick-config.png
header:profunda
===
tanto mudar impulso de pulo quanto gravidade influenciam altura do pulo
mais ainda: quando o gato t√° grudado a um prop, o peso do prop e os multiplicadores tamb√©m influenciam
---

# compos√≠vel
qu√£o f√°cil √© a intera√ß√£o com outras abstra√ß√µes?
(mais pr√°tico quando h√° um canal uniforme que integra sistemas)
header:profunda
===
um pouco menos pr√°tico para os nossos casos j√° que costumamos fazer sistemas especializados.
algo a se levar em conta ao analizar c√≥digos de terceiros.
---

compos√≠vel
# narrow waist
exemplo: unix pipeline
```
ls -l | grep key | less
```
header:profunda
footer:[a sketch of the biggest idea in software architecture](https://www.oilshell.org/blog/2022/03/backlog-arch.html)
===
faca de dois legumes: facilita a comunica√ß√£o entre sistemas, limita a comunica√ß√£o entre sistemas
---

compos√≠vel
# callbacks
preferir api imediata
callbacks adicionam indire√ß√£o ao fluxo de c√≥digo
footer:[immediate-mode graphical user interfaces - 2005](https://www.youtube.com/watch?v=Z1qyvQsjK5Y)
===
principalmente em implementa√ß√µes de m√≥dulos, onde depend√™ncias diretas n√£o importam,
preferir chamar fun√ß√µes diretamente a fim de eliminar indire√ß√µes.
---

compos√≠vel
# padr√£o liga/desliga
```
// evitar
void Enable(); // this.enabled = true; ...
void Disable(); // this.enabled = false; ...
// eventualmente for√ßa um `if` em alguma camada

// preferir
void SetEnabled(bool enabled); // this.enabled = enabled; ...
// por√©m nem sempre poss√≠vel!
```
===
quando fizer sentido, juntar duas fun√ß√µes em uma caso suas implementa√ß√µes permitam.
separar cedo em mais de uma fun√ß√£o enventualmente for√ßa introduzir um `if` desnecessariamente.
o estado novo pode vir de uma configura√ß√£o ou de uma outra fun√ß√£o que o recebe como par√¢metro.
---

compos√≠vel
# late binding x early binding
no in√≠cio, queremos simplicidade
no final, queremos controle total
header:profunda
===
"binding" √© um conceito que vem de programa√ß√£o funcional. basicamente significa dar um nome a um valor (to bind).
"late binding" era uma das propostas de alan kay em sua vis√£o para orienta√ß√£o a objetos realizada em smalltalk.
a linguagem deixa pra decidir no √∫ltimo momento qual o valor que um nome tem.
temos reflexo disso em fun√ß√µes virtuais + overloading em que o c√≥digo que ser√° executado s√≥ √© sabido na hora da chamada.

n√£o √© bom nem ruim por si s√≥. depende do contexto.

late binding d√° flexibilidade por√©m dificulta valida√ß√£o. e vice-versa para early binding.
---

exemplo
# late binding dialogo neko
```
class UNekoDialogueCharacterDataAsset : public UDataAsset {
    ENekoDialogueCharacterId Id = ENekoDialogueCharacterId::None;

    TArray<TSoftObjectPtr<UTexture2D>> Expressions;

    // implementado com for
    UTexture2D* GetExpression(ENekoDialogueCharacterExpression Expression);
};
```
header:profunda
===
todas as express√µes ficam no array expressions.
teoricamente temos flexibilidade pra configurar as express√µes,
mas na pr√°tica, todos os personagems v√£o ter as mesmas entradas.
f√°cil esquecer ou duplicar uma express√£o por n√£o ter valida√ß√£o.

`GetExpression` √© um `for` que busca uma entrada em `Expressions` que seja do tipo `Expression`. opera√ß√£o fal√≠vel.
---

exemplo
# early binding dialogo neko
```
class UNekoDialogueCharacterDataAsset : public UDataAsset {
    ENekoDialogueCharacterId Id = ENekoDialogueCharacterId::None;

    TSoftObjectPtr<UTexture2D> ExpressionDefault;
    TSoftObjectPtr<UTexture2D> ExpressionAngry;
    TSoftObjectPtr<UTexture2D> ExpressionHappy;

    // implementado com switch
    UTexture2D* GetExpression(ENekoDialogueCharacterExpression Expression);
};
```
header:profunda
===
agora listamos todas as express√µes explicitamente.
imposs√≠vel duplicar. esquecer uma express√£o significa ter um buraco vazio no editor.

`GetExpression` agora √© um `switch` que √© implementado na m√£o. por√©m agora √© uma opera√ß√£o infal√≠vel.
---

# complexidade adicionada < complexidade abstra√≠da
abstra√ß√µes devem puxar mais que seu pr√≥prio peso
entender os tradeoffs feitos
header:profunda
---

complexidade adicionada < complexidade abstra√≠da
# desempenho
- √© um sistema pervasivo? muitas entidades?
- onde h√° um, h√° muitos! qual o caso comum? operar em lotes!
- agrupar por tipos ao inv√©s de cole√ß√µes heterog√™neas
- particionar ao inv√©s de branch
- multithread? job system?
header:profunda
---

# padr√µes razo√°veis
almejar criar um "pit of success" pra quem for usar
header:interface enxuta
---

padr√µes razo√°veis
# "data driven"
extrair dados est√°ticos em arquivos separados
- unity: scriptable objects
- unreal: data asset
header:interface enxuta
===
separar dado que n√£o muda/config em arquivos separados pra facilitar altera√ß√£o, organiza√ß√£o e controle
---

padr√µes razo√°veis
# estruturas de dados
arrays *muito* provavelmente s√£o suficientes
processadores adoram mem√≥ria linear
\*olha feio praquela lista encadeada\* üò†
header:interface enxuta
---

# estado m√≠nimo
sobre quais os dados a api opera?
onde eles s√£o alterados?
header:interface enxuta
footer:[in detph: functional programming in c++](https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-)
footer:[twitter - sobre estado](https://mobile.twitter.com/rygorous/status/1507178315886444544)
===
n√£o √© sobre anarquia! :B
facilitar entendimento e reflex√£o por diminuir "partes m√≥veis".
---

estado m√≠nimo
# const correctness
preferir estilo funcional sempre que poss√≠vel
facilita compreens√£o. menos dependente de ordem de execu√ß√£o
```
// evitar
obj.CheckSomething();
obj.MaybeDoSomethingInResponse();

// preferir
var result = obj.CheckSomething();
if (result) {
    obj.DoSomethingInResponse(result);
}
```
header:interface enxuta
footer:[c++ const correctness](https://isocpp.org/wiki/faq/const-correctness)
===
as linhas serem breves s√£o um falso indicador da complexidade por tr√°s uma vez que
para realmente entender o que est√° acontecendo, agora devemos ter em mente o estado interno de `obj`.
mudar a ordem das linhas ou esquecer uma delas facilmente causar√° bugs.

aqui `CheckSomething` n√£o modifica o estado interno de obj e apenas retorna o resultado calculado.
enquanto `DoSomethingInResponse` explicitamente age em cima do resultado obtido.
tamb√©m est√° expl√≠cito o `if` que antes estava escondido em `MaybeDoSomethingInResponse`.

ex: maquina de estados opengl.
---

estado m√≠nimo
# recursos e posse
quem √© o respons√°vel pelo recurso?
posse vs empr√©stimo
onde h√° aloca√ß√£o de mem√≥ria? poss√≠vel evit√°-la?
- c# = preferir structs e arrays; reusar cole√ß√µes
- c++ = arrays; inline allocator;
header:interface enxuta
footer:[c# memory and spans - owners, consumers and lifetime management](https://docs.microsoft.com/en-us/dotnet/standard/memory-and-spans/memory-t-usage-guidelines#owners-consumers-and-lifetime-management)
footer:[List.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L25)
footer:[TInlineAllocator](https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Containers/TInlineAllocator/)
---

# invariantes expl√≠citas
+ pr√©-condi√ß√µes
+ p√≥s-condi√ß√µes
header:interface enxuta
===
uma propriedade do sistema que √© sempre verdade.
ex: esse ponteiro sempre aponta para mem√≥ria v√°lida.
---

invariantes expl√≠citas
# null
pr√©-condi√ß√£o: quais fun√ß√µes podem *receber* null?
p√≥s-condi√ß√£o: quais fun√ß√µes podem *retornar* null?
decidir e ser expl√≠cito!

linguagens mais recentes t√™m esse conceito embutido (rust, zig, kotlin, c#8)
- c# da unity n√£o tem isso
- bitstrap: `Option<T>`
header:interface enxuta
footer:[Option.cs](https://github.com/bitcake/bitstrap/blob/master/Assets/Runtime/Functional/Option.cs)
---

invariantes expl√≠citas
# minimizar erros
dois tipos de erros:
- entrada/sa√≠da => tratar
- l√≥gica => assert

header:interface enxuta
footer:"define errors out of existence" -- ousterhout, john
footer:[assertions should be more debugger-oriented](https://nullprogram.com/blog/2022/06/26/)
footer:[how "let it fail" leats to simpler code](https://yiming.dev/blog/2022/07/10/how-let-it-fail-leads-to-simpler-code/)
===
qualquer outro tipo de erro √© desnecess√°rio
---

exemplo
# pepper CommandTokenizer
```
open "folder/some file.txt
# ops, esqueci de fechar aspas ^
```
===
antes existiam v√°rios tratamentos de erro por conta de tratamento de strings ao parsear comandos no editor pepper.
por√©m mudar a semantica para uma aspa n√£o fechada significa string at√© o final da linha fez com que parsear comando
se tornasse uma opera√ß√£o infal√≠vel. ainda pode acontecer erro de sem√¢ntica, mas todos os c√≥digos que lidavam com o
tokenizador passaram a ser muito mais enxutos.
---

invariantes expl√≠citas
# intervalo de valores
usar tipos para codificar valores v√°lidos
```
// evitar
int GetPlayerCount();

// preferir
uint8 GetPlayerCount();
```
header:interface enxuta
===
mesma coisa tamb√©m para par√¢metros de fun√ß√µes e membros de structs/classes.
---

# intui sua implementa√ß√£o
a partir de uma transforma√ß√£o conhecida, √© poss√≠vel inferir aproximadamente suas entradas e sa√≠das
header:interface enxuta
footer:[principle of least surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)
===
quando nos dispomos a implementar um sistema, intuitivamente devemos ter no√ß√£o da forma de suas entradas e sa√≠das.
da mesma forma quando vamos consumir uma api que se prop√µe a resolver um determinado problema,
temos uma no√ß√£o do que esperar de sua interface.

ex: api para baixar arquivo (url)
ex: api para desenhar ret√¢ngulo (x, y, w, h, color)

em cada um dos exemplos, d√° pra se aprofundar em mais detalhes:
http vs ftp vs tcp/ip; rota√ß√£o, tamanho borda, gradiente vs textura; etc.

por√©m o importante √© que ainda assim, o formato das entradas e sa√≠das ainda se assemelham ao intuido.
se, por outro lado, a interface diverge demais do esperado, √© prov√°vel que n√£o seja uma boa api.
---

intui sua implementa√ß√£o
# debugabilidade
- onde est√£o os dados?
- s√£o f√°ceis de inspecionar?
- √© f√°cil acompanhar o que est√° acontecendo pelo debugger?
header:interface enxuta
---

# √†s vezes n√£o precisa de api ou abstra√ß√£o
## c√≥digo vai, design fica
background:galaxy-brain.png
===
nosso trabalho √© resolver problema. escrever c√≥digo √© consequ√™ncia.

reutilizar design √© mais √∫til que reutilizar c√≥digo!
√†s vezes for√ßar reutiliza√ß√£o de c√≥digo apenas adicionar complexidade sem realmente adicionar valor a quem usa
---

exemplo
# classe AssetLoader
```
pub trait Asset: Sync + Send + 'static {
    type Id: fmt::Debug + Hash + Eq + Clone + Sync + Send;
}
pub trait AssetLoader<'a, A: Asset> {
    type Storage;
    fn load(&'a self, id: &A::Id, storage: &mut Self::Storage) -> Result<A, AssetLoadError>;
}
pub fn try_load<'a, S>(
    &mut self,
    id: &A::Id,
    loader: &'a AssetLoader<'a, A, Storage = S>,
    storage: &mut S,
) -> Result<AssetHandle<A>, AssetLoadError> {
    match self.cache_map.get(id).cloned() {
        Some(handle) => Ok(handle),
        None => {
            let asset = loader.load(id, storage)?;
            let handle = self.add(asset);
            self.cache_map.insert(id.clone(), handle);
            Ok(handle)
        }
    }
}
```
===
come√ßou como uma abstra√ß√£o template pra carregar assets de v√°rios tipos a partir de um path.
at√© que chegamos em fontes, que precisam de um path + font-size. quebrou a abstra√ß√£o precoce!
acontece que eu continuei no caminho da abstra√ß√£o criando mais camadas adicionando mais templates
se distanciando cada vez mais da solu√ß√£o do problema: carregar assets do disco.

enquanto isso, a solu√ß√£o basicamente *pedia* que fosse separada em v√°rias structs ao inves de uma gen√©rica.
anos depois quando fui programar meu editor de c√≥digo, n√£o cai na mesma armadilha e separei as cole√ß√µes de
Buffers, BufferViews, Plugins e Clients (todas t√™m um Handle associado).
Dessa forma, √© super f√°cil de adicionar funcionalidade pr√≥pria de cada cole√ß√£o sem influenciar ou estar amarrado
√†s outras cole√ß√µes.

basicamente um "falso cognato" de design!
- duas coisas que a princ√≠pio se parecem e teriam um design parecido
- mas na pr√°tica t√™m opera√ß√µes diferentes que impossibilita uma interface √∫nica
---

exemplo
# classe timer v1
```
public class Timer { // holodrive
    [SerializeField] private float length = 1.0f; // serializado
    private float counter = 0.0f;
    public System.Action OnTimer { get; set; } // callback

    public void OnUpdate() {
        if( counter < 0.0f ) {
            // Already triggered callback.
        } else if( counter < length ) {
            counter += Time.deltaTime;
        } else {
            counter = -1.0f;
            if( OnTimer != null )
                OnTimer();
        }
    }
}
```
===
v√°rios detalhes omitidos
cl√°ssica implementa√ß√£o orientada a objetos

`length` √© serializado no MonoBehaviour
callbacks s√£o configurados no Start/Awake
---

exemplo
# classe timer v2
```
public sealed class Timer { // demagnete
    public float length = 1.0f; // dinamico
    private float elapsedTime = -1.0f;

    public bool OnUpdate() { // sem callback
        if( elapsedTime >= 0.0f )
            elapsedTime += Time.deltaTime;
        if( elapsedTime < length ) {
            elapsedTime = -1.0f;
            return true;
        }
        return false;
    }
}
```
===
quase sempre o que a gente queria, na verdade, era configurar a dura√ß√£o do timer em um ScriptableObject.
igualmente, os callbacks costumavam ser bem curtos. suas declara√ß√µes eram ru√≠do.

antes de iniciar o timer, muda o valor de `length` com base num ScriptableObject.
api "immediate mode" aproveitando que `OnUpdate` j√° precisava ser chamado todo frame.
c√≥digo do callback inline dentro de um `if`. bem mais f√°cil de acompanhar os caminhos de c√≥digo.
---

exemplo
# classe timer v3
```
float Timer = -1.0f; // neko
// ...
void AMyActor::Tick(float DeltaSeconds) {
    if (Timer >= 0.0f) {
        Timer += DeltaSeconds;
        if (Timer >= Config->TimerDuration) {
            // do the thing!
            Timer = -1.0f;
        }
    }
}
```
===
em sua √∫ltima itera√ß√£o, n√£o existe mais classe timer.
agora √© apenas um idioma. um padr√£o que emerge nos c√≥digos.
adicionar uma classe apenas aumentaria a complexidade com ganhos √≠nfimos.
n√£o h√° mais a necessidade de abstrair.

para come√ßar o timer, √© s√≥ fazer `Timer = 0.0f`.

bonus: reparar que √© poss√≠vel aumentar o `TimerDuration` enquanto o timer est√° rodando e continua funcionando.
---

# 3 big lies
- software is a platform
- code should be designed around a model of the world
- code is more important than data
background:main
footer:[three big lies](https://cellperformance.beyond3d.com/articles/2008/03/three-big-lies.html)
===
software is a platform
- hardware √© a platforma
- pra nos lembrar das implica√ß√µes de desempenho que nossas abstra√ß√µes implicam

code should be designed around a model of the world
- dados e suas transforma√ß√µes devem guiar o design
- pre-mapear rela√ß√µes e conceitos de mundo em uma solu√ß√£o apenas adiciona ruido e restri√ß√µes desnecess√°rias
    - e, portanto, dificulta chegar ao melhor design

code is more important than data
- dados s√£o mais importantes
- c√≥digo n√£o existe pra ser bonito. a solu√ß√£o n√£o existe pra ser bonita. ambos existem pra resolver o problema
- as apis devem refletir isso. elas *precisam* resolver o problema e nada mais.
    - caso contrario apenas adicionam complexidade acidental ao sistema
---

# design de api = ponderar custo-benef√≠cios
"everything should be made as simple as possible, but not simpler."
-- einstein, albert (supostamente)
footer:valeu! falou! :)
===
"tudo deve ser feito o mais simples poss√≠vel, por√©m n√£o mais simples que isso."

uma solu√ß√£o que poderia ser mais simples possui desperd√≠cio.
uma solu√ß√£o que √© simples demais ignora detalhes importantes.

√© atrav√©s de simplicidade que atingimos apis balanceadas entre custo e benef√≠cio
---

!!links
===
