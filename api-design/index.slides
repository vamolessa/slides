# design de apis
## workshop bitcake 2022
background:main
footer:por @ahvamolessa
---

# *api* é apresentar *abstrações* através de uma *interface*
background:thinker.jpg
===
não é apenas sobre "application programming interface".
mas sobre interfaces em geral e os lados de quem cria e de quem consome.
---

# por que interfaces?
===
por que interfaces são importantes e por que falar a respeito?
é uma forma (comum) de abordar desenvolvimento de software onde
nós dividimos um problema complexo em camadas e/ou componentes.
a forma como essa divisão acontece é introduzindo interfaces.
isso nos permite limitar o raciocínio necessário quanto à resolução de problema
ao inves de precisar manter um contexto enorme em mente mesmo ao realizar uma simples modificação.
---

# abstrações
background:imagination.jpg
===
esse ato de encapsular complexidade a fim de simplificar seu uso é abstrair.
interfaces estão intrinsicamente relacionada a abstrações.
e abstrações são fundamentais ao gerenciamento de complexidade
---

# é um modelo com o propósito de interpretar uma realidade rica em detalhes
## alcançado por introduzir conceitos pertinentes ao domínio
background:complexity.jpg
===
nossa maior ferramenta para lidar com complexidade.
a base inteira de computação é feita por cima de camadas que abstraem detalhes cada vez mais baixo nível.

uma abstração apenas pode ser criada por associar um conceito do domínio em questão aos detalhes que desejamos esconder.
muitas vezes criando conceitos novos no processo.
---

# abstrair = faca de dois legumes
## esconder complexidade *adiciona* complexidade
background:faca-dois-legumes.jpg
===
abstrair significa esconder detalhes adicionando presunções implícitas (contexto) que
quem interagir com tal abstração deve estar a par.

exemplo mais básico desse processo é dar nome a coisas. um nome carrega conceito e significado.
por conta disso, uma abstração nova sempre vai pelo menos aumentar a carga cognitiva de um sistema.

porém sua vantagem está em justamente criar uma nova forma (supostamente mais simples)
de raciocinar a respeito de um problema ou sistema.
é um instrumento de comunicação. uma ferramenta.
---

# abstrair != remover complexidade
## esconder significa que ainda está lá
===
importantíssimo lembrar que os detalhes ainda estão lá!
abstrair não significa que eles deixam de existir ou que podemos ignorá-los completamente.
---

# problemas complexos são complexos
a única maneira de simplificar um problema inerenentemente complexo é resolvendo outro problema (que seja mais simples)
===
resolver outro problema pode significar mudar o design (e tudo bem)!

nosso trabalho não é implementar o que o desginer ou producer pedem,
mas sim *entender* o problema e então resolvê-lo
fazer as perguntas certas!
comunicação! entender o problema!
---

## escrever mais código que o necessário *por definição* apenas aumenta a complexidade da solução
footer:[john carmack on inlined code](http://number-none.com/blow/john_carmack_on_inlined_code.html)
===
tentar quebrar o problema em pedaços menores não remove complexidade
criar mais classes não o torna mais simples
criar mais funções não o torna mais simples
(inclusive pode apenas dificultar o entendimento da solução e, por consequência, da api)
---

# complexidade inerente vs complexidade acidental
## inerente
- propriedades fundamentais do problema
- única maneira de reduzi-la é mudando o problema (e tudo bem!)

## acidental
- adicionada por nós mesmos
- idealmente zero
- limitações (linguagem, plataforma, design)
===
todo problema possui uma complexidade inerente.
qualquer complexidade extra é acidental e deve ser ativamente minimizada.
PRECISAMOS refletir honestamente se não estamos inconscientemente adicionando complexidade acidental ao sistema!
---

# como saber qual complexidade estamos introduzindo?
- entender o problema
- prototipação
- testar soluções diferentes. refatorar
- evitar grandes soluções genéricas
- evitar future proofing ("fool's errand")

erros e limitações serão encontrados independente da quantidade de design investido a priori. aceite-os e planeje-se!

footer:[dig shallow graves](https://ourmachinery.com/post/dig-shallow-graves/)
footer:[best practices for godot engine contributors](https://docs.godotengine.org/en/stable/community/contributing/best_practices_for_engine_contributors.html)
===
entender o problema é fundamental.
prototipação é como se entende o problema!
comunicação! comunicação com quem vai usar o sistema. quais são suas reais necessidades?
a única maneira de acertar um bom design de primeira é com muita sorte ou ter experiência prévia resolvendo tal problema.
é sobre a jornada! prototipar, iterar e refatorar!
---

# código reutilizável vs código fácil de deletar
## a única forma de criar código reutilizável é extraindo-o de código fácil de deletar
footer:[semantic compression](https://caseymuratori.com/blog_0015)
footer:[how to write disposable code in large systems](https://programmingisterrible.com/post/139222674273/how-to-write-disposable-code-in-large-systems)
---

# apesar de tudo, abstrações vazam
## sem exceção
footer:[why black boxes are so hard to reuse](https://www.youtube.com/watch?v=5l2wMgm7ZOk)
===
acontece que abstrações infelizmente têm essa propriedade de inevitavelmente vazar detalhes de sua implementação.
não importa o quão boa é uma abstração. ela vaza detalhes de alguma forma.

ou seja: não existe abstração perfeita. alguma coisa sempre se perde.
e pode acontecer até de ter um ganho negativo: a abstração deixa o sistema em geral mais complexo do que seria sem ela.

ex de abstracao:
- carro manual => passar marcha é um vazamento da implementação do carro (como funciona internamente)
- carro automatico => não é 100% pois ainda existem `1`, `2`, `P`, além do `D`
- mesmo que fosse "100%", ainda existe manutenção => precisa entender quando precisa levar ao mecânico, checar agua, oleo, etc
- toda abstração vaza detalhes de implementação!
	- e tudo bem! isso não invalida suas utilidades
	- porem, existe um gradiente aí! mesmo sempre existindo vazamento, é de nosso interesse minimizá-lo!!

TODO: citar? https://www.youtube.com/watch?v=rHIkrotSwcc&list=LLkSsu_JvG53vwdMNEDCLLqQ&index=11
---

# abstrações apenas têm valor quando levantam seu próprio peso
## "programmers know the benefits of everything and the tradeoffs of nothing"
footer:[simplicity matters](https://www.youtube.com/watch?v=rI8tNMsozo0)
===
importante pra nos lembrar dos custos de adicionar abstrações a um sistema nos guia a onde traçamos apis.

lembrar que no inicio, queremos super agilidade, porém no final, queremos total controle.
---

# apis e abstrações *não* existem no vácuo
- o que: abstrações
- intenção de uso: interface
- quem usa: comunicação
- restrições: linguagem, plataforma, inércia dos códigos já existentes
footer:[performance and good data design](https://cellperformance.beyond3d.com/articles/2006/04/performance-and-good-data-design.html)
footer:[c++: unordered_multiset's api affects its big-o](https://quuxplusone.github.io/blog/2022/06/23/unordered-multiset-equal-range/)
===
- o que: custos de abstração
- intenção de uso: uso da api é tão importante quanto sua implementação
- quem usa: entender o problema. as reais necessidades de quem vai usar a api
- restrições: o que a gente tem pra trabalhar. alvos de desempenho, etc. códigos já escritos que irão interagir com o sistema novo

tomar decisão informada quanto a onde traçamos a linha da abstração
---

# uma api é boa se ela é *profunda* e possui *interface enxuta*
background:main
footer:[a philosophy of software design](https://www.youtube.com/watch?v=bmSAYlu0NcY)
===
enfim do que é feita uma boa api!
criar abstrações que adicionam valor substancial ao sistema, à solução e aos usuários.
---

# granularidade
abstrações acontecem em vários níveis, mas o potencial é proporcional à escala
background:granularity.jpg
===
níveis: nome, função, classe, módulo, programa, sistema, etc.
temos mais potencial de profundidade quanto maior a escala.

realidade: classes são granulares demais para promoverem sozinhas uma api profunda.

isso nos induz a manter interfaces permissivas e flutuantes entre classes de um mesmo módulo/sistema.
e deixar pra implementar interfaces formais e impenetráveis de api a nível de módulos no mínimo.

na prática: encapsulamento (getter/setter, variáveis e funções privadas/protegidas, arquivos super fragmentados, etc)
não são importantes enquanto estamos no mesmo módulo.
é tudo parte de uma mesma implementação: a abstração principal do sistema.

TODO: paramo aqui
---

# profunda
- ortogonal
- composível
- complexidade adicionada < complexidade abstraída
# interface enxuta
- padrões razoáveis
- estado mínimo e explícito
- pré-condições + invariantes + pós-condições
- intui sua implementação
===
TODO: paramo logo depois daqui
---

# ortogonal
header:profunda
===
conceitos são independentes e não se influenciam
---

# composível
header:profunda
===
é permitido e talvez até fácil de interagir com outras abstrações
---

# complexidade adicionada < complexidade abstraída
header:profunda
===
puxar mais que seu próprio peso
---

# padrões razoáveis
header:interface enxuta
===
criar um "pit of success" pra quem for usar
---

# estado mínimo e explícito
header:interface enxuta
footer:[in detph: functional programming in c++](https://www.gamedeveloper.com/programming/in-depth-functional-programming-in-c-)
===
facilitar entendimento e reflexão por diminuir "partes móveis".
ex: ordem de execução
ex: maquina de estados opengl
---

# pré-condições + invariantes + pós-condições
header:interface enxuta
===
explicidade. também gerenciamento de erros
	Const correctness.
	Sempre preferir funções puras quando possível.
	É um espectro, tentar sempre empurrar funções pro lado mais puro.

	ex:
	- null
		- linguagens mais recentes têm esse conceito embutido (rust, zig, kotlin, C#8)
		- C# da unity não tem isso
		- BitStrap: `Option<T>`
	- range de valores
	- ordem de execução
---

# intui sua implementação
header:interface enxuta
===
faz parte da interface saber (pelo menos) superficialmente sobre sua implementação.
---

# às vezes não precisa de api ou abstração
## código vai, design fica
background:galaxy-brain.png
===
nosso trabalho é resolver problema. escrever código é consequência.

reutilizar design é mais útil que reutilizar código!
às vezes forçar reutilização de código apenas adicionar complexidade sem realmente adicionar valor a quem usa
- exemplo da `resource collection` genéricas do jogo plataforma em rust que nunca chegou a existir
- exemplo do `load asset` que recebia um caminho para carregamento e que também funcionava como chave de um cache
	- quebrou rapidamente pois assets de fonte também precisam do parametro do tamanho da fonte
	- isso levou a um monte de codigo estilo template que distanciava do real problema que deveria ser resolvido:
		- carregar e cachear assets
- comparar com as coleções que existem no pepper
	- parecidas porém não 100%
	- facil de adicionar propriedades exclusivas e realmente aconteceu!
---

# 3 big lies
- software is a platform
- code should be designed around a model of the world
- code is more important than data

background:main
footer:[three big lies](https://cellperformance.beyond3d.com/articles/2008/03/three-big-lies.html)
===
- software is a platform
	- hardware é a platforma
	- pra nos lembrar das implicações de desempenho que nossas abstrações implicam
- code should be designed around a model of the world
	- dados e suas transformações devem guiar o design
	- pre-mapear relações e conceitos de mundo em uma solução apenas adiciona ruido e restrições desnecessárias
		- e, portanto, dificulta chegar ao melhor design
- code is more important than data
	- dados são mais importantes
	- código não existe pra ser bonito. a solução não existe pra ser bonita. ambos existem pra resolver o problema
	- as apis devem refletir isso. elas *precisam* resolver o problema e nada mais.
		- caso contrario apenas adicionam complexidade acidental ao sistema
---

# extras práticos
background:main
---

# late binding x early binding
no início, queremos simplicidade
no final, queremos controle total
---

# debugabilidade
onde estão os dados?
são fáceis de inspecionar?
é fácil acompanhar o que está acontecendo pelo debugger?
---

# estruturas de dados
arrays *muito* provavelmente são suficientes
processadores adoram memória linear
\*olha feio praquela lista encadeada\*
---

# recursos e posse
quem é o responsável pelo recurso?
posse vs emprestimo
onde há alocação de memória? da pra evitá-la?

C# = preferir structs e arrays; reusar coleções
C++ = arrays; inline allocator;

footer:[List.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L25)
footer:[TInlineAllocator](https://docs.unrealengine.com/5.0/en-US/API/Runtime/Core/Containers/TInlineAllocator/)
---

# desempenho
é um sistema pervasivo? muitas entidades?
onde há um, há muitos! qual o caso comum? operar em lotes!
agrupar por tipos ao invés de coleções heterogêneas
particionar ao invés de branch
multithread? job system?
---

# design de api = ponderar custo-benefícios
"everything should be made as simple as possible, but not simpler."
-- einstein, albert (supostamente)
footer:valeu! falou! :)
===
"tudo deve ser feito o mais simples possível, porém não mais simples que isso."

uma solução que poderia ser mais simples possui desperdício.
uma solução que é simples demais ignora detalhes importantes.

===
## exemplos
https://mobile.twitter.com/rygorous/status/1507178315886444544

- dados estáticos em scriptable objects
	- já fazemos isso!
	- moral: separar dado que não muda/config em arquivos separados pra facilitar alteração, organização e controle

- classe Timer (Holodrive e depois BitStrap)
	- começo era classe com timer e duration e callback
	- depois struct e duration vinha de scriptable object
	- ai reparamo que também não precisava de callback
	- hoje eu colapsaria tudo em apenas uma função tipo o `SmoothDamp` da unity (recebe um `ref float timer` por parâmetro)
	- moral: não juntar dado com comportamento cedo demais

	- pergunta: `timer > 0.0f && timer -= delta_time_s` ou `timer < duration && timer += delta_time_s`?
		- `timer < duration` permite alterar o `duration` enquanto o timer tá rolando e continua funcionando como esperado!

- scene config demagnete
	- começou com tentar reaproveitar código genérico feito sem necessidade a ser resolvida
	- teve potencial suficiente pra ser possível implementar outros tipos de nós posteriormente
- sistema de dialogos neko
	- mudou por questão de usabilidade (alan usou de forma diferente)
	- mudou por entender melhor o problema (passar dialogo localmente x apenas o server passa)
- BitStrap
	- um bando de código reutilizável extraídos de um bando de código fácil de deletar

